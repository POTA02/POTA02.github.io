<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LIVE: Bot vs Bot Chess Battle</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            background: linear-gradient(135deg, #0f0f0f 0%, #1a1a2e 50%, #16213e 100%);
            font-family: 'Arial', sans-serif;
        }
        
        .live-indicator {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .chat-message {
            animation: slideInRight 0.3s ease-out;
        }
        
        @keyframes slideInRight {
            from { transform: translateX(20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .chess-board {
            width: 100%;
            max-width: 400px;
            aspect-ratio: 1/1;
            margin: 0 auto;
            border: 3px solid #3b82f6;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .square {
            position: relative;
            width: 12.5%;
            height: 12.5%;
            float: left;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .light { background-color: #f0d9b5; }
        .dark { background-color: #b58863; }
        
        .piece {
            width: 80%;
            height: 80%;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 1;
        }
        
        .viewer-count {
            background: linear-gradient(45deg, #ff0000, #ff6600);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: glow 2s infinite alternate;
        }
        
        @keyframes glow {
            from { filter: drop-shadow(0 0 5px rgba(255, 0, 0, 0.5)); }
            to { filter: drop-shadow(0 0 15px rgba(255, 102, 0, 0.8)); }
        }
        
        .bot-thinking {
            animation: thinking 1.5s infinite;
        }
        
        @keyframes thinking {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        
        .stream-quality {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
        }
    </style>
</head>
<body class="text-white min-h-screen">
    <!-- Header with Live Indicator -->
    <header class="bg-black bg-opacity-50 backdrop-blur-md border-b border-red-500 p-4">
        <div class="max-w-7xl mx-auto flex items-center justify-between">
            <div class="flex items-center gap-4">
                <div class="live-indicator bg-red-500 text-white px-3 py-1 rounded-full text-sm font-bold">
                    <i class="fas fa-circle text-xs mr-1"></i>LIVE
                </div>
                <h1 class="text-2xl font-bold text-white">
                    <i class="fas fa-robot mr-2"></i>ChessBot Arena
                </h1>
            </div>
            <div class="flex items-center gap-6">
                <div class="viewer-count text-xl font-bold">
                    <i class="fas fa-eye mr-1"></i><span id="viewerCount">1,247</span>
                </div>
                <button class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded-lg transition">
                    <i class="fas fa-heart mr-1"></i>Follow
                </button>
            </div>
        </div>
    </header>

    <div class="max-w-7xl mx-auto p-4 grid grid-cols-1 lg:grid-cols-4 gap-6">
        <!-- Main Game Area -->
        <div class="lg:col-span-3 space-y-4">
            <!-- Player Info -->
            <div class="bg-gray-800 bg-opacity-80 backdrop-blur-md rounded-lg p-4 border border-gray-600">
                <div class="grid grid-cols-2 gap-4">
                    <!-- Bot 1 Info -->
                    <div class="bg-blue-900 bg-opacity-50 rounded-lg p-4 border-l-4 border-blue-400">
                        <div class="flex items-center gap-3 mb-2">
                            <div class="w-12 h-12 bg-blue-500 rounded-full flex items-center justify-center">
                                <i class="fas fa-robot text-xl"></i>
                            </div>
                            <div>
                                <h3 class="font-bold text-lg">AlphaChess v2.1</h3>
                                <p class="text-blue-300 text-sm">Rating: 2847</p>
                            </div>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-3 h-3 bg-white rounded-full"></div>
                            <span class="text-sm">Playing as White</span>
                            <div id="bot1Status" class="ml-auto text-xs bg-green-500 px-2 py-1 rounded">Ready</div>
                        </div>
                    </div>
                    
                    <!-- Bot 2 Info -->
                    <div class="bg-gray-900 bg-opacity-50 rounded-lg p-4 border-l-4 border-gray-400">
                        <div class="flex items-center gap-3 mb-2">
                            <div class="w-12 h-12 bg-gray-500 rounded-full flex items-center justify-center">
                                <i class="fas fa-robot text-xl"></i>
                            </div>
                            <div>
                                <h3 class="font-bold text-lg">DeepMind Chess</h3>
                                <p class="text-gray-300 text-sm">Rating: 2832</p>
                            </div>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-3 h-3 bg-black rounded-full border border-white"></div>
                            <span class="text-sm">Playing as Black</span>
                            <div id="bot2Status" class="ml-auto text-xs bg-yellow-500 px-2 py-1 rounded">Thinking...</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Chess Board -->
            <div class="bg-gray-800 bg-opacity-80 backdrop-blur-md rounded-lg p-6 border border-gray-600">
                <div class="chess-board mx-auto" id="chessBoard"></div>
                
                <!-- Game Controls -->
                <div class="mt-4 flex justify-center gap-4">
                    <button id="pauseBtn" class="bg-yellow-600 hover:bg-yellow-700 px-4 py-2 rounded-lg transition">
                        <i class="fas fa-pause mr-1"></i>Pause
                    </button>
                    <button id="restartBtn" class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded-lg transition">
                        <i class="fas fa-redo mr-1"></i>New Game
                    </button>
                    <button id="speedBtn" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded-lg transition">
                        <i class="fas fa-tachometer-alt mr-1"></i>Speed: 1x
                    </button>
                </div>
            </div>

            <!-- Game Stats -->
            <div class="bg-gray-800 bg-opacity-80 backdrop-blur-md rounded-lg p-4 border border-gray-600">
                <h3 class="text-lg font-bold mb-3">
                    <i class="fas fa-chart-line mr-2"></i>Live Stats
                </h3>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
                    <div>
                        <div class="text-2xl font-bold text-blue-400" id="moveCount">0</div>
                        <div class="text-sm text-gray-400">Moves</div>
                    </div>
                    <div>
                        <div class="text-2xl font-bold text-green-400" id="gameTime">00:00</div>
                        <div class="text-sm text-gray-400">Game Time</div>
                    </div>
                    <div>
                        <div class="text-2xl font-bold text-yellow-400" id="evaluation">+0.00</div>
                        <div class="text-sm text-gray-400">Evaluation</div>
                    </div>
                    <div>
                        <div class="text-2xl font-bold text-purple-400" id="depth">0</div>
                        <div class="text-sm text-gray-400">Search Depth</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Chat Sidebar -->
        <div class="bg-gray-800 bg-opacity-80 backdrop-blur-md rounded-lg border border-gray-600 flex flex-col h-96 lg:h-auto">
            <!-- Chat Header -->
            <div class="bg-gray-700 bg-opacity-80 p-3 rounded-t-lg border-b border-gray-600">
                <h3 class="font-bold">
                    <i class="fas fa-comments mr-2"></i>Live Chat
                    <span class="text-sm text-gray-400 ml-2">(1,247 viewers)</span>
                </h3>
            </div>
            
            <!-- Chat Messages -->
            <div class="flex-1 p-3 space-y-2 overflow-y-auto" id="chatContainer">
                <div class="chat-message text-sm">
                    <span class="text-red-400 font-bold">ChessMaster99:</span>
                    <span class="text-gray-300">This is going to be epic! üî•</span>
                </div>
                <div class="chat-message text-sm">
                    <span class="text-blue-400 font-bold">BotWatcher:</span>
                    <span class="text-gray-300">AlphaChess looking strong today</span>
                </div>
                <div class="chat-message text-sm">
                    <span class="text-green-400 font-bold">StreamFan2024:</span>
                    <span class="text-gray-300">Anyone know the opening they're playing?</span>
                </div>
                <div class="chat-message text-sm">
                    <span class="text-purple-400 font-bold">ChessAnalyst:</span>
                    <span class="text-gray-300">Looks like Sicilian Defense</span>
                </div>
                <div class="chat-message text-sm">
                    <span class="text-yellow-400 font-bold">RobotFan:</span>
                    <span class="text-gray-300">DeepMind is calculating so deep! ü§ñ</span>
                </div>
            </div>
            
            <!-- Chat Input -->
            <div class="p-3 border-t border-gray-600">
                <div class="flex gap-2">
                    <input type="text" id="chatInput" placeholder="Say something..." 
                           class="flex-1 bg-gray-700 text-white px-3 py-2 rounded-lg border border-gray-500 focus:border-blue-400 focus:outline-none text-sm">
                    <button id="sendChat" class="bg-blue-600 hover:bg-blue-700 px-3 py-2 rounded-lg transition">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Stream Quality Indicator -->
    <div class="fixed bottom-4 right-4 stream-quality px-3 py-2 rounded-lg text-sm">
        <i class="fas fa-wifi text-green-400 mr-1"></i>
        <span class="text-green-400">1080p ‚Ä¢ 60fps</span>
    </div>

    <!-- Include Chess Engine and Bots -->
    <script src="chess-engine.js"></script>
    <script src="chess-ai.js"></script>

    <script>
        // Game state
        let chessEngine;
        let whiteBot;
        let blackBot;
        let gameRunning = true;
        let gameSpeed = 1;
        let gameStartTime = Date.now();
        let isThinking = false;

        // Initialize the game
        function initGame() {
            chessEngine = new ChessEngine();
            whiteBot = BOT_PROFILES.alphaChess;
            blackBot = BOT_PROFILES.deepMind;
            
            renderBoard();
            updateStats();
            updateBotStatus();
            
            // Start the game after a short delay
            setTimeout(playNextMove, 2000);
        }

        // Render the chess board
        function renderBoard() {
            const boardElement = document.getElementById('chessBoard');
            boardElement.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    
                    // Add rank and file notation
                    if (col === 0) {
                        const rank = document.createElement('div');
                        rank.className = 'rank-label';
                        rank.style.cssText = 'position: absolute; top: 2px; left: 2px; font-size: 10px; font-weight: bold; pointer-events: none;';
                        rank.textContent = 8 - row;
                        square.appendChild(rank);
                    }
                    
                    if (row === 7) {
                        const file = document.createElement('div');
                        file.className = 'file-label';
                        file.style.cssText = 'position: absolute; bottom: 2px; right: 2px; font-size: 10px; font-weight: bold; pointer-events: none;';
                        file.textContent = String.fromCharCode(97 + col);
                        square.appendChild(file);
                    }
                    
                    const piece = chessEngine.board[row][col];
                    if (piece) {
                        const pieceElement = document.createElement('div');
                        pieceElement.className = 'piece';
                        const svg = getPieceSVG(piece.type, piece.color);
                        pieceElement.innerHTML = svg;
                        square.appendChild(pieceElement);
                    }
                    
                    boardElement.appendChild(square);
                }
            }
        }

        // Play the next move
        async function playNextMove() {
            if (!gameRunning || chessEngine.gameOver || isThinking) return;

            isThinking = true;
            updateBotStatus();

            const currentBot = chessEngine.currentPlayer === 'white' ? whiteBot : blackBot;
            
            try {
                const move = await currentBot.chooseMove(chessEngine, gameSpeed);
                
                if (move && gameRunning) {
                    // Make the move
                    const success = chessEngine.makeMove(
                        move.from.row, move.from.col, 
                        move.to.row, move.to.col
                    );
                    
                    if (success) {
                        // Update display
                        renderBoard();
                        updateStats();
                        updateMoveHistory(move, currentBot);
                        
                        // Add chat commentary
                        addBotCommentary(move, currentBot);
                        
                        // Check for game end
                        if (chessEngine.gameOver) {
                            handleGameEnd();
                        }
                    }
                }
            } catch (error) {
                console.error('Error making move:', error);
            } finally {
                isThinking = false;
                updateBotStatus();
                
                // Schedule next move if game continues
                if (!chessEngine.gameOver && gameRunning) {
                    setTimeout(playNextMove, (1500 + Math.random() * 1000) / gameSpeed);
                }
            }
        }

        // Update game statistics
        function updateStats() {
            document.getElementById('moveCount').textContent = chessEngine.moveHistory.length;
            
            const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('gameTime').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Get evaluation from current position
            const currentBot = chessEngine.currentPlayer === 'white' ? whiteBot : blackBot;
            const evaluation = chessEngine.evaluatePosition() / 100; // Convert to pawn units
            document.getElementById('evaluation').textContent = 
                (evaluation >= 0 ? '+' : '') + evaluation.toFixed(2);
            
            // Show search depth
            document.getElementById('depth').textContent = currentBot.getSearchDepth();
        }

        // Update bot status indicators
        function updateBotStatus() {
            const bot1Status = document.getElementById('bot1Status');
            const bot2Status = document.getElementById('bot2Status');
            
            // Add intelligence indicator based on speed
            let intelligenceText = '';
            if (gameSpeed === 2) {
                intelligenceText = ' ü§™'; // Dumber mode
            } else if (gameSpeed === 0.5) {
                intelligenceText = ' üß†'; // Smarter mode
            }
            
            if (chessEngine.gameOver) {
                bot1Status.textContent = 'Game Over';
                bot1Status.className = 'ml-auto text-xs bg-red-500 px-2 py-1 rounded';
                bot2Status.textContent = 'Game Over';
                bot2Status.className = 'ml-auto text-xs bg-red-500 px-2 py-1 rounded';
                return;
            }
            
            if (isThinking) {
                if (chessEngine.currentPlayer === 'white') {
                    bot1Status.textContent = 'Thinking...' + intelligenceText;
                    bot1Status.className = 'ml-auto text-xs bg-yellow-500 px-2 py-1 rounded bot-thinking';
                    bot2Status.textContent = 'Waiting';
                    bot2Status.className = 'ml-auto text-xs bg-gray-500 px-2 py-1 rounded';
                } else {
                    bot2Status.textContent = 'Thinking...' + intelligenceText;
                    bot2Status.className = 'ml-auto text-xs bg-yellow-500 px-2 py-1 rounded bot-thinking';
                    bot1Status.textContent = 'Waiting';
                    bot1Status.className = 'ml-auto text-xs bg-gray-500 px-2 py-1 rounded';
                }
            } else {
                if (chessEngine.currentPlayer === 'white') {
                    bot1Status.textContent = 'Ready' + intelligenceText;
                    bot1Status.className = 'ml-auto text-xs bg-green-500 px-2 py-1 rounded';
                    bot2Status.textContent = 'Waiting';
                    bot2Status.className = 'ml-auto text-xs bg-gray-500 px-2 py-1 rounded';
                } else {
                    bot2Status.textContent = 'Ready' + intelligenceText;
                    bot2Status.className = 'ml-auto text-xs bg-green-500 px-2 py-1 rounded';
                    bot1Status.textContent = 'Waiting';
                    bot1Status.className = 'ml-auto text-xs bg-gray-500 px-2 py-1 rounded';
                }
            }
        }

        // Add move to history and display
        function updateMoveHistory(move, bot) {
            const fromSquare = String.fromCharCode(97 + move.from.col) + (8 - move.from.row);
            const toSquare = String.fromCharCode(97 + move.to.col) + (8 - move.to.row);
            const moveNotation = `${fromSquare}-${toSquare}`;
            
            console.log(`${bot.name} played: ${moveNotation}`);
        }

        // Add bot commentary to chat
        function addBotCommentary(move, bot) {
            let commentaries = [];
            let commentChance = 0.3;
            
            // Speed-specific commentary
            if (gameSpeed === 2) {
                // 2x speed = simplified commentary
                commentaries = [
                    `${bot.name} rushes that move... questionable choice`,
                    `Fast but not very accurate from ${bot.name}`,
                    `${bot.name} is moving quickly but missing tactics`,
                    `Speed over accuracy for ${bot.name}`,
                    `${bot.name} makes a hasty decision`,
                    `That's what happens when you play too fast!`,
                    `${bot.name} blunders under time pressure`,
                    `Not the best move from ${bot.name}...`,
                ];
                commentChance = 0.5; // More commentary for bad moves
            } else if (gameSpeed === 0.5) {
                // 0.5x speed = detailed commentary
                commentaries = [
                    `Brilliant calculation by ${bot.name}!`,
                    `${bot.name} finds the perfect move after deep analysis`,
                    `Masterful positioning from ${bot.name}`,
                    `${bot.name} demonstrates computer precision`,
                    `Flawless technique from ${bot.name}`,
                    `${bot.name} calculates like a supercomputer`,
                    `Incredible depth of analysis by ${bot.name}`,
                    `${bot.name} plays with godlike precision`,
                    `That's the power of deep thinking!`,
                ];
                commentChance = 0.4; // More commentary for great moves
            } else {
                // Normal speed commentary
                commentaries = [
                    `Strong move by ${bot.name}!`,
                    `Interesting positional play`,
                    `${bot.name} maintains the advantage`,
                    `Tactical awareness on display`,
                    `That's why they're rated ${bot.rating}!`,
                    `Precise calculation from ${bot.name}`,
                    `The engine finds the best continuation`,
                    `Perfect timing for that move`,
                    `${bot.name} shows superior understanding`,
                    `Clinical technique being displayed`
                ];
            }
            
            if (Math.random() < commentChance) {
                const commentary = commentaries[Math.floor(Math.random() * commentaries.length)];
                addChatMessage('ChessAnalyst', 'text-cyan-400', commentary);
            }
        }

        // Handle game end
        function handleGameEnd() {
            const status = chessEngine.getGameStatus();
            addChatMessage('GameSystem', 'text-red-400', status);
            
            // Update UI to show game over
            setTimeout(() => {
                if (confirm(`${status} Would you like to start a new game?`)) {
                    restartGame();
                }
            }, 2000);
        }

        // Restart the game
        function restartGame() {
            chessEngine = new ChessEngine();
            gameStartTime = Date.now();
            isThinking = false;
            gameRunning = true;
            
            renderBoard();
            updateStats();
            updateBotStatus();
            
            // Clear chat and add restart message
            addChatMessage('GameSystem', 'text-green-400', 'New game started!');
            
            setTimeout(playNextMove, 2000);
        }

        // Chess piece SVGs (same as before)
        function getPieceSVG(type, color) {
            const pieceColor = color === 'white' ? '#fff' : '#000';
            const oppositeColor = color === 'white' ? '#000' : '#fff';
            
            switch(type) {
                case 'pawn':
                    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
                        <path d="M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z" 
                        stroke="${oppositeColor}" fill="${pieceColor}" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>`;
                case 'rook':
                    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
                        <g fill="${pieceColor}" stroke="${oppositeColor}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M9 39h27v-3H9v3zM12 36v-4h21v4H12zM11 14V9h4v2h5V9h5v2h5V9h4v5"/>
                            <path d="M34 14l-3 3H14l-3-3"/>
                            <path d="M31 17v12.5H14V17"/>
                            <path d="M31 29.5l1.5 2.5h-20l1.5-2.5z"/>
                            <path d="M11 14h23"/>
                        </g>
                    </svg>`;
                case 'knight':
                    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
                        <g fill="${pieceColor}" stroke="${oppositeColor}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21"/>
                            <path d="M24 18c.38 2.91-5.55 7.37-8 9-3 2-2.82 4.34-5 4-1.042-.94 1.41-3.04 0-3-1 0 .19 1.23-1 2-1 0-4.003 1-4-1 0-2 6-12 6-12s1.89-1.9 2-3.5c-.73-.994-.5-2-.5-3 1-1 3 2.5 3 2.5h2s.78-1.992 2.5-3c1 0 1 3 1 3"/>
                            <circle cx="9.5" cy="25.5" r=".5" fill="${oppositeColor}"/>
                            <circle cx="14.933" cy="15.75" r="1" fill="${oppositeColor}"/>
                        </g>
                    </svg>`;
                case 'bishop':
                    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
                        <g fill="${pieceColor}" stroke="${oppositeColor}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .5-3.39-.97-10.11.46-13.5-1-3.39 1.46-10.11.03-13.5 1-1.354.49-2.323.47-3-.5 1.354-1.94 3-2 3-2z"/>
                            <path d="M15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z"/>
                            <circle cx="22.5" cy="8.5" r="2.5" stroke="${oppositeColor}"/>
                        </g>
                    </svg>`;
                case 'queen':
                    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
                        <g fill="${pieceColor}" stroke="${oppositeColor}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M9 26c8.5-1.5 21-1.5 27 0l2.5-12.5L31 25l-.3-14.1-5.2 13.6-3-14.5-3 14.5-5.2-13.6L14 25 6.5 13.5 9 26z"/>
                            <path d="M9 26c0 2 1.5 2 2.5 4 1 1.5 1 1 .5 3.5-1.5 1-1 2.5-1 2.5-1.5 1.5 0 2.5 0 2.5 6.5 1 16.5 1 23 0 0 0 1.5-1 0-2.5 0 0 .5-1.5-1-2.5-.5-2.5-.5-2 .5-3.5 1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z"/>
                            <path d="M11.5 30c3.5-1 18.5-1 22 0m-21.5 1.5c2-1 15-1 17 0" fill="none"/>
                        </g>
                    </svg>`;
                case 'king':
                    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
                        <g fill="${pieceColor}" stroke="${oppositeColor}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M22.5 11.63V6M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5"/>
                            <path d="M12.5 37c5.5 3.5 14.5 3.5 20 0v-7s9-4.5 6-10.5c-4-6.5-13.5-3.5-16 4V27v-3.5c-2.5-7.5-12-10.5-16-4-3 6 6 10.5 6 10.5v7"/>
                            <path d="M20 8h5"/>
                            <circle cx="22.5" cy="6.5" r="2" stroke="${oppositeColor}"/>
                        </g>
                    </svg>`;
                default:
                    return '';
            }
        }

        // Chat functionality
        function addChatMessage(username = 'Anonymous', colorClass = 'text-gray-400', message = '') {
            const chatContainer = document.getElementById('chatContainer');
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message text-sm';
            messageDiv.innerHTML = `
                <span class="${colorClass} font-bold">${username}:</span>
                <span class="text-gray-300">${message}</span>
            `;
            
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            
            // Remove old messages if too many
            if (chatContainer.children.length > 25) {
                chatContainer.removeChild(chatContainer.firstChild);
            }
        }

        // Auto-generate chat messages
        function generateAutoChat() {
            const chatMessages = [
                {name: 'ChessLover', color: 'text-red-400', message: 'This position is getting complex!'},
                {name: 'BotExpert', color: 'text-blue-400', message: 'Great positional understanding'},
                {name: 'StreamViewer', color: 'text-green-400', message: 'Who has the advantage here?'},
                {name: 'AIFanatic', color: 'text-purple-400', message: 'The evaluation keeps changing!'},
                {name: 'ChessNoob', color: 'text-yellow-400', message: 'Can someone explain that move?'},
                {name: 'ProAnalyst', color: 'text-cyan-400', message: 'Perfect technique from both bots'},
                {name: 'RandomUser', color: 'text-pink-400', message: 'This is so entertaining!'},
                {name: 'TechNerd', color: 'text-orange-400', message: 'Amazing how deep these bots calculate'}
            ];

            if (Math.random() < 0.4) { // 40% chance every interval
                const randomMsg = chatMessages[Math.floor(Math.random() * chatMessages.length)];
                addChatMessage(randomMsg.name, randomMsg.color, randomMsg.message);
            }
        }

        // Control buttons (with null checks)
        const pauseBtn = document.getElementById('pauseBtn');
        if (pauseBtn) {
            pauseBtn.addEventListener('click', function() {
                gameRunning = !gameRunning;
                this.innerHTML = gameRunning ? 
                    '<i class="fas fa-pause mr-1"></i>Pause' : 
                    '<i class="fas fa-play mr-1"></i>Resume';
                
                if (gameRunning && !chessEngine.gameOver) {
                    playNextMove();
                }
            });
        }

        const restartBtn = document.getElementById('restartBtn');
        if (restartBtn) {
            restartBtn.addEventListener('click', function() {
                if (confirm('Are you sure you want to start a new game?')) {
                    restartGame();
                }
            });
        }

        const speedBtn = document.getElementById('speedBtn');
        if (speedBtn) {
            speedBtn.addEventListener('click', function() {
                gameSpeed = gameSpeed === 1 ? 2 : gameSpeed === 2 ? 0.5 : 1;
                
                let speedText = '';
                let aiDescription = '';
                
                if (gameSpeed === 2) {
                    speedText = 'Speed: 2x';
                    aiDescription = ' (AI plays DUMBER)';
                    addChatMessage('GameSystem', 'text-yellow-400', '‚ö° 2x Speed Mode: Bots are now playing much faster but less intelligently!');
                } else if (gameSpeed === 0.5) {
                    speedText = 'Speed: 0.5x';
                    aiDescription = ' (AI plays SMARTER)';
                    addChatMessage('GameSystem', 'text-blue-400', 'üß† 0.5x Speed Mode: Bots are now thinking deeper and playing much smarter!');
                } else {
                    speedText = 'Speed: 1x';
                    aiDescription = ' (Normal AI)';
                    addChatMessage('GameSystem', 'text-green-400', '‚öñÔ∏è Normal Speed: Bots are back to standard intelligence level.');
                }
                
                this.innerHTML = `<i class="fas fa-tachometer-alt mr-1"></i>${speedText}${aiDescription}`;
            });
        }

        // Chat input (with null checks)
        const sendChatBtn = document.getElementById('sendChat');
        const chatInput = document.getElementById('chatInput');
        
        if (sendChatBtn && chatInput) {
            sendChatBtn.addEventListener('click', function() {
                if (chatInput.value.trim()) {
                    addChatMessage('You', 'text-green-400', chatInput.value);
                    chatInput.value = '';
                }
            });

            chatInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendChatBtn.click();
                }
            });
        }

        // Viewer count animation
        function updateViewerCount() {
            const viewerCount = document.getElementById('viewerCount');
            const baseCount = 1247;
            const variation = Math.floor(Math.random() * 30) - 15;
            viewerCount.textContent = (baseCount + variation).toLocaleString();
        }

        // Initialize everything
        initGame();

        // Start periodic updates
        setInterval(updateStats, 1000);
        setInterval(generateAutoChat, 12000);
        setInterval(updateViewerCount, 20000);

        // Add some initial chat messages
        setTimeout(() => addChatMessage('StreamMod', 'text-red-400', 'Welcome to the bot battle!'), 1000);
        setTimeout(() => addChatMessage('ChessExpert', 'text-blue-400', 'This should be a great match'), 3000);
    </script>
</body>
</html>
    <svg id="site-logo" width="48" height="48" viewBox="0 0 48 48" class="mr-4 transition-colors duration-100" xmlns="http://www.w3.org/2000/svg">
        <circle cx="24" cy="24" r="20" fill="#ef4444"/>
        <text x="24" y="30" text-anchor="middle" font-size="18" fill="#fff" font-family="Arial" font-weight="bold">C</text>
    </svg>
    <h1 class="text-3xl md:text-6xl font-bold text-center text-red-500">COMMUNIST CHESS</h1>

</div>

        
        <div class="flex flex-col md:flex-row items-center justify-center gap-6 md:gap-12">
            <div class="chess-board relative bg-gray-800 shadow-2xl rounded-lg overflow-hidden">
            </div>
            
            <div class="w-full md:w-80 mt-4 md:mt-0">
                <div class="bg-gray-800 rounded-lg p-6 shadow-lg min-h-[400px]">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-bold">INFO</h2>
                        <button id="turn-indicator" class="w-6 h-6 rounded-full border-2 border-white cursor-pointer hover:opacity-80 transition-opacity" title="Click to switch sides"></button>
                    </div>
                    
                    <div class="mb-4">
                        <p class="text-sm font-semibold">Turn: <span id="current-turn">White</span></p>
                        <p class="text-sm font-semibold">Status: <span id="game-status">Playing</span></p>
                    </div>
                    
                    <div class="mb-4">
                        <p class="text-sm font-semibold mb-1">Captured Pieces:</p>
                        <div id="captured-pieces" class="flex flex-wrap gap-1 min-h-8"></div>
                    </div>
                    
                    <div class="flex flex-col gap-2">
                        <button id="new-game" class="bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded-lg transition">
                            New Game
                        </button>
                        <button id="advanced-hints-btn" class="advanced-hints-button py-2 px-4 rounded-lg transition font-bold hidden">ADVANCED HINTS</button>
                        <button id="undo-move" class="bg-gray-600 hover:bg-gray-700 text-white py-2 px-4 rounded-lg transition">
                            Undo Move(im dumb)
                        </button>
                        <button id="share-pieces" class="bg-purple-600 hover:bg-purple-700 text-white py-2 px-4 rounded-lg transition">
                            SHARE PIECES
                        </button>
                        <button id="bot-move-btn" class="bot-move-button py-2 px-4 rounded-lg transition font-bold hidden">MAKE BOT MOVE</button>
                            <button id="goated-btn" class="mt-2 w-full py-2 px-4 rounded-lg font-extrabold text-lg shadow-lg transition-transform hover:scale-105 bg-gradient-to-r from-pink-500 via-yellow-400 to-blue-500 text-white border-4 border-pink-400 animate-pulse">GOATED BUTTON</button>
                    </div>
                    
                    <div class="mt-4">
                        <p class="text-xs text-gray-400">Click a piece to select it, then click a highlighted square to move.</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="promotion-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
            <div class="bg-gray-800 p-6 rounded-lg shadow-xl">
                <h3 class="text-xl font-bold mb-4 text-center">Promote Pawn</h3>
                <div class="grid grid-cols-4 gap-2">
                    <div class="promotion-option bg-gray-700 hover:bg-gray-600 p-2 rounded cursor-pointer" data-piece="queen">
                        <div class="piece w-full h-12 bg-[url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 45 45\"><g fill=\"none\" fill-rule=\"evenodd\" stroke=\"%23000\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M9 26c8.5-1.5 21-1.5 27 0l2.5-12.5L31 25l-.3-14.1-5.2 13.6-3-14.5-3 14.5-5.2-13.6L14 25 6.5 13.5 9 26z\" stroke=\"%23fff\"/><path d=\"M9 26c0 2 1.5 2 2.5 4 1 1.5 1 1 .5 3.5-1.5 1-1 2.5-1 2.5-1.5 1.5 0 2.5 0 2.5 6.5 1 16.5 1 23 0 0 0 1.5-1 0-2.5 0 0 .5-1.5-1-2.5-.5-2.5-.5-2 .5-3.5 1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z\" stroke=\"%23fff\"/><path d=\"M11.5 30c3.5-1 18.5-1 22 0m-21.5 1.5c2-1 15-1 17 0\" fill=\"%23fff\"/></svg>')]"></div>
                        <p class="text-center mt-1 text-sm">Queen</p>
                    </div>
                    <div class="promotion-option bg-gray-700 hover:bg-gray-600 p-2 rounded cursor-pointer" data-piece="rook">
                        <div class="piece w-full h-12 bg-[url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 45 45\"><g fill=\"none\" fill-rule=\"evenodd\" stroke=\"%23000\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M9 39h27v-3H9v3zM12 36v-4h21v4H12zM11 14V9h4v2h5V9h5v2h5V9h4v5\" stroke=\"%23fff\"/><path d=\"M34 14l-3 3H14l-3-3\" stroke=\"%23fff\"/><path d=\"M31 17v12.5H14V17\" stroke=\"%23fff\"/><path fill=\"%23fff\" d=\"M31 29.5l1.5 2.5h-20l1.5-2.5z\"/><path d=\"M11 14h23\" stroke=\"%23fff\"/></svg>')]"></div>
                        <p class="text-center mt-1 text-sm">Rook</p>
                    </div>
                    <div class="promotion-option bg-gray-700 hover:bg-gray-600 p-2 rounded cursor-pointer" data-piece="bishop">
                        <div class="piece w-full h-12 bg-[url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 45 45\"><g fill=\"none\" fill-rule=\"evenodd\" stroke=\"%23000\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .5-3.39-.97-10.11.46-13.5-1-3.39 1.46-10.11.03-13.5 1-1.354.49-2.323.47-3-.5 1.354-1.94 3-2 3-2z\" stroke=\"%23fff\"/><path d=\"M15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z\" stroke=\"%23fff\"/><path d=\"M25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z\" stroke=\"%23fff\"/></svg>')]"></div>
                        <p class="text-center mt-1 text-sm">Bishop</p>
                    </div>
                    <div class="promotion-option bg-gray-700 hover:bg-gray-600 p-2 rounded cursor-pointer" data-piece="knight">
                        <div class="piece w-full h-12 bg-[url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 45 45\"><g fill=\"none\" fill-rule=\"evenodd\" stroke=\"%23000\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21\" stroke=\"%23fff\"/><path d=\"M24 18c.38 2.91-5.55 7.37-8 9-3 2-2.82 4.34-5 4-1.042-.94 1.41-3.04 0-3-1 0 .19 1.23-1 2-1 0-4.003 1-4-1 0-2 6-12 6-12s1.89-1.9 2-3.5c-.73-.994-.5-2-.5-3 1-1 3 2.5 3 2.5h2s.78-1.992 2.5-3c1 0 1 3 1 3\" stroke=\"%23fff\"/><path d=\"M9.5 25.5a.5.5 0 1 1-1 0 .5.5 0 1 1 1 0zm5.433-9.75a.5 1.5 30 1 1-.866-.5 .5 1.5 30 1 1 .866.5z\" fill=\"%23fff\" stroke=\"%23fff\"/></svg>')]"></div>
                        <p class="text-center mt-1 text-sm">Knight</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="choice-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl max-w-md w-full">
            <h3 class="text-xl font-bold mb-4 text-center">Choose Your Path</h3>
            <input type="text" id="choice-input" class="w-full p-2 mb-4 bg-gray-700 border border-gray-600 rounded" placeholder="Dictatorship or Anarchy?">
            <button id="submit-choice" class="w-full bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded-lg transition">
                Submit
            </button>
        </div>
    </div>

    <script>
        // Beta popup logic
        document.addEventListener('DOMContentLoaded', function() {
            const rulesPopup = document.getElementById('rules-popup');
            const rulesReason = document.getElementById('rules-reason');
            const reasonText = document.getElementById('reason-text');
            const rulesPopupInner = document.getElementById('rules-popup-inner');
            const betaPopup = document.getElementById('beta-popup');
            const rollingText = document.getElementById('rolling-text');
            const mergedClose = document.getElementById('merged-close');
            const mergedCloseBeta = document.getElementById('merged-close-beta');
            let reasonShown = false;
            
            function showReason() {
                if (!reasonShown) {
                    reasonText.textContent = 'I was too lazy.';
                    reasonText.style.height = '2.5rem';
                    rulesPopupInner.style.paddingBottom = '2.5rem';
                    reasonShown = true;
                } else {
                    reasonText.textContent = '';
                    reasonText.style.height = '0';
                    rulesPopupInner.style.paddingBottom = '';
                    reasonShown = false;
                }
            }
            
            if (rulesReason) {
                rulesReason.addEventListener('click', showReason);
            }
            
            function showBetaVersion(container, text) {
                // Change text to beta message
                text.textContent = "This is a beta release";
                
                // Wait 0.9 seconds and then close
                return new Promise(resolve => {
                    setTimeout(() => {
                        resolve();
                    }, 900);
                });
            }
            
            if (mergedClose) {
                mergedClose.addEventListener('click', function() {
                    const container = rulesPopupInner;
                    const text = container.querySelector('h2');
                    
                    showBetaVersion(container, text).then(() => {
                        // Close both popups if visible
                        if (rulesPopup) rulesPopup.style.display = 'none';
                        if (betaPopup) betaPopup.style.display = 'none';
                    });
                });
            }
            
            if (mergedCloseBeta) {
                mergedCloseBeta.addEventListener('click', function() {
                    const container = betaPopup.querySelector('.rounded-2xl');
                    const text = rollingText;
                    
                    showBetaVersion(container, text).then(() => {
                        if (rulesPopup) rulesPopup.style.display = 'none';
                        if (betaPopup) betaPopup.style.display = 'none';
                    });
                });
            }
            
            // Show beta popup after rules
            if (mergedClose) {
                rulesPopup.addEventListener('transitionend', function() {
                    if (rulesPopup.style.display === 'none') {
                        betaPopup.style.display = 'flex';
                        rollingText.classList.remove('animate-rolling');
                        void rollingText.offsetWidth;
                        rollingText.classList.add('animate-rolling');
                    }
                });
            }
            
            // Prevent game interaction until popups are closed
            document.body.classList.add('overflow-hidden');
            function hidePopupsEnableGame() {
                document.body.classList.remove('overflow-hidden');
            }
            // Hide popups after beta
            if (betaPopup) {
                betaPopup.addEventListener('transitionend', hidePopupsEnableGame);
            }
            
            // GOATED BUTTON: change background to colorful gradient
            const goatedBtn = document.getElementById('goated-btn');
            if (goatedBtn) {
                goatedBtn.addEventListener('click', function() {
                    document.body.classList.remove('bg-gray-900');
                    document.body.style.background = 'linear-gradient(135deg, #ec4899 0%, #fde047 50%, #3b82f6 100%)';
                    document.body.style.transition = 'background 0.7s cubic-bezier(.4,2,.6,1)';
                    goatedBtn.style.display = 'none';
                });
            }
        });
        document.addEventListener('DOMContentLoaded', function() {
            // Game state
            const game = {
                board: Array(8).fill().map(() => Array(8).fill(null)),
                turn: 'white',
                selectedSquare: null,
                possibleMoves: [],
                moveHistory: [],
                capturedPieces: { white: [], black: [] },
                check: false,
                gameOver: false,
                lastMove: null,
                newGameClickCount: 0, // Easter egg counter
                advancedHintsEnabled: false,
                botMoveUsed: false, // Track if the one-time bot move has been used
                
                init() {
                    this.setupBoard();
                    this.renderBoard();
                    this.setupEventListeners();
                    this.updateGameInfo();
                },
                
                setupBoard() {
                    // Set up pawns
                    for (let col = 0; col < 8; col++) {
                        this.board[1][col] = { type: 'pawn', color: 'black', hasMoved: false };
                        this.board[6][col] = { type: 'pawn', color: 'white', hasMoved: false };
                    }
                    
                    // Set up rooks
                    this.board[0][0] = { type: 'rook', color: 'black', hasMoved: false };
                    this.board[0][7] = { type: 'rook', color: 'black', hasMoved: false };
                    this.board[7][0] = { type: 'rook', color: 'white', hasMoved: false };
                    this.board[7][7] = { type: 'rook', color: 'white', hasMoved: false };
                    
                    // Set up knights
                    this.board[0][1] = { type: 'knight', color: 'black' };
                    this.board[0][6] = { type: 'knight', color: 'black' };
                    this.board[7][1] = { type: 'knight', color: 'white' };
                    this.board[7][6] = { type: 'knight', color: 'white' };
                    
                    // Set up bishops
                    this.board[0][2] = { type: 'bishop', color: 'black' };
                    this.board[0][5] = { type: 'bishop', color: 'black' };
                    this.board[7][2] = { type: 'bishop', color: 'white' };
                    this.board[7][5] = { type: 'bishop', color: 'white' };
                    
                    // Set up queens
                    this.board[0][3] = { type: 'queen', color: 'black' };
                    this.board[7][3] = { type: 'queen', color: 'white' };
                    
                    // Set up kings
                    this.board[0][4] = { type: 'king', color: 'black', hasMoved: false };
                    this.board[7][4] = { type: 'king', color: 'white', hasMoved: false };
                },
                
                renderBoard() {
                    const boardElement = document.querySelector('.chess-board');
                    boardElement.innerHTML = '';
                    
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 8; col++) {
                            const square = document.createElement('div');
                            square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                            square.dataset.row = row;
                            square.dataset.col = col;
                            
                            // Add notation for ranks (1-8) and files (a-h)
                            if (col === 0) {
                                const rank = document.createElement('div');
                                rank.className = 'notation rank';
                                rank.textContent = 8 - row;
                                square.appendChild(rank);
                            }
                            
                            if (row === 7) {
                                const file = document.createElement('div');
                                file.className = 'notation file';
                                file.textContent = String.fromCharCode(97 + col);
                                square.appendChild(file);
                            }
                            
                            // Add piece if exists
                            const piece = this.board[row][col];
                            if (piece) {
                                const pieceElement = document.createElement('div');
                                pieceElement.className = 'piece';
                                pieceElement.dataset.piece = piece.type;
                                pieceElement.dataset.color = piece.color;
                                
                                // Set SVG background based on piece type and color
                                const svg = this.getPieceSVG(piece.type, piece.color);
                                pieceElement.style.backgroundImage = `url('data:image/svg+xml;utf8,${encodeURIComponent(svg)}')`;
                                
                                square.appendChild(pieceElement);
                            }
                            
                            boardElement.appendChild(square);
                        }
                    }
                },
                
                getPieceSVG(type, color) {
                    const pieceColor = color === 'white' ? '#fff' : '#000';
                    const oppositeColor = color === 'white' ? '#000' : '#fff';
                    
                    switch(type) {
                        case 'pawn':
                            return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
                                <path d="M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z" 
                                stroke="${oppositeColor}" fill="${pieceColor}" stroke-width="1.5" stroke-linecap="round"/>
                            </svg>`;
                        case 'rook':
                            return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
                                <g fill="${pieceColor}" stroke="${oppositeColor}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M9 39h27v-3H9v3zM12 36v-4h21v4H12zM11 14V9h4v2h5V9h5v2h5V9h4v5"/>
                                    <path d="M34 14l-3 3H14l-3-3"/>
                                    <path d="M31 17v12.5H14V17"/>
                                    <path d="M31 29.5l1.5 2.5h-20l1.5-2.5z"/>
                                    <path d="M11 14h23"/>
                                </g>
                            </svg>`;
                        case 'knight':
                            return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
                                <g fill="${pieceColor}" stroke="${oppositeColor}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21"/>
                                    <path d="M24 18c.38 2.91-5.55 7.37-8 9-3 2-2.82 4.34-5 4-1.042-.94 1.41-3.04 0-3-1 0 .19 1.23-1 2-1 0-4.003 1-4-1 0-2 6-12 6-12s1.89-1.9 2-3.5c-.73-.994-.5-2-.5-3 1-1 3 2.5 3 2.5h2s.78-1.992 2.5-3c1 0 1 3 1 3"/>
                                    <circle cx="9.5" cy="25.5" r=".5" fill="${oppositeColor}"/>
                                    <circle cx="14.933" cy="15.75" r="1" fill="${oppositeColor}"/>
                                </g>
                            </svg>`;
                        case 'bishop':
                            return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
                                <g fill="${pieceColor}" stroke="${oppositeColor}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .5-3.39-.97-10.11.46-13.5-1-3.39 1.46-10.11.03-13.5 1-1.354.49-2.323.47-3-.5 1.354-1.94 3-2 3-2z"/>
                                    <path d="M15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z"/>
                                    <circle cx="22.5" cy="8.5" r="2.5" stroke="${oppositeColor}"/>
                                </g>
                            </svg>`;
                        case 'queen':
                            return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
                                <g fill="${pieceColor}" stroke="${oppositeColor}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M9 26c8.5-1.5 21-1.5 27 0l2.5-12.5L31 25l-.3-14.1-5.2 13.6-3-14.5-3 14.5-5.2-13.6L14 25 6.5 13.5 9 26z"/>
                                    <path d="M9 26c0 2 1.5 2 2.5 4 1 1.5 1 1 .5 3.5-1.5 1-1 2.5-1 2.5-1.5 1.5 0 2.5 0 2.5 6.5 1 16.5 1 23 0 0 0 1.5-1 0-2.5 0 0 .5-1.5-1-2.5-.5-2.5-.5-2 .5-3.5 1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z"/>
                                    <path d="M11.5 30c3.5-1 18.5-1 22 0m-21.5 1.5c2-1 15-1 17 0" fill="none"/>
                                </g>
                            </svg>`;
                        case 'king':
                            return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
                                <g fill="${pieceColor}" stroke="${oppositeColor}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M22.5 11.63V6M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5"/>
                                    <path d="M12.5 37c5.5 3.5 14.5 3.5 20 0v-7s9-4.5 6-10.5c-4-6.5-13.5-3.5-16 4V27v-3.5c-2.5-7.5-12-10.5-16-4-3 6 6 10.5 6 10.5v7"/>
                                    <path d="M20 8h5"/>
                                    <circle cx="22.5" cy="6.5" r="2" stroke="${oppositeColor}"/>
                                </g>
                            </svg>`;
                        default:
                            return '';
                    }
                },
                
                setupEventListeners() {
                    const board = document.querySelector('.chess-board');
                    
                    // Turn indicator click handler (with null check)
                    const turnIndicator = document.getElementById('turn-indicator');
                    if (turnIndicator) {
                        turnIndicator.addEventListener('click', () => {
                            this.switchTurns();
                            this.clearSelection();
                        });
                    }

                    // Share pieces button handler (with null check)
                    const sharePiecesBtn = document.getElementById('share-pieces');
                    if (sharePiecesBtn) {
                        sharePiecesBtn.addEventListener('click', () => {
                            // Collect all pieces on the board
                            const pieces = [];
                            for (let row = 0; row < 8; row++) {
                                for (let col = 0; col < 8; col++) {
                                    if (this.board[row][col]) {
                                        pieces.push({
                                            piece: this.board[row][col],
                                            row,
                                            col
                                        });
                                        this.board[row][col] = null;
                                    }
                                }
                            }

                            // Randomly distribute pieces to black and white
                            pieces.forEach(({piece, row, col}) => {
                                piece.color = Math.random() < 0.5 ? 'white' : 'black';
                                this.board[row][col] = piece;
                            });

                            // Update the display
                            this.renderBoard();
                            this.clearSelection();
                            this.updateGameInfo();
                        });
                    }
                    
                    // Square click handler
                    board.addEventListener('click', (e) => {
                        if (this.gameOver) return;
                        
                        const square = e.target.closest('.square');
                        if (!square) return;
                        
                        const row = parseInt(square.dataset.row);
                        const col = parseInt(square.dataset.col);
                        
                        // If no piece is selected, select this one if it's the current player's color
                        if (this.selectedSquare === null) {
                            const piece = this.board[row][col];
                            if (piece && piece.color === this.turn) {
                                this.selectSquare(row, col);
                            }
                        } 
                        // If a piece is selected, try to move it here if it's a valid move
                        else {
                            const [fromRow, fromCol] = this.selectedSquare;
                            
                            // Check if this is a valid move
                            if (this.isValidMove(fromRow, fromCol, row, col)) {
                                this.movePiece(fromRow, fromCol, row, col);
                                this.clearSelection();
                            } 
                            // If clicking on another piece of the same color, select that instead
                            else {
                                const piece = this.board[row][col];
                                if (piece && piece.color === this.turn) {
                                    this.selectSquare(row, col);
                                } else {
                                    this.clearSelection();
                                }
                            }
                        }
                    });
                    
                    // New game button (with null check)
                    const newGameBtn = document.getElementById('new-game');
                    if (newGameBtn) {
                        newGameBtn.addEventListener('click', () => {
                            this.newGameClickCount++;
                            console.log('New game clicked:', this.newGameClickCount, 'times');
                            
                            if (this.newGameClickCount >= 5 && !this.advancedHintsEnabled) {
                                this.enableAdvancedHints();
                            } else {
                                this.resetGame();
                            }
                        });
                    }
                    
                    // Undo move button (with null check)
                    const undoMoveBtn = document.getElementById('undo-move');
                    if (undoMoveBtn) {
                        undoMoveBtn.addEventListener('click', () => {
                            this.undoMove();
                        });
                    }
                    
                    // Promotion selection
                    document.querySelectorAll('.promotion-option').forEach(option => {
                        option.addEventListener('click', (e) => {
                            const pieceType = e.currentTarget.dataset.piece;
                            this.completePromotion(pieceType);
                        });
                    });
                },
                
                selectSquare(row, col) {
                    this.clearSelection();
                    
                    // Save selected square
                    this.selectedSquare = [row, col];
                    
                    // Highlight selected square
                    const square = this.getSquareElement(row, col);
                    square.classList.add('highlight');
                    
                    // Calculate and show possible moves
                    this.possibleMoves = this.calculatePossibleMoves(row, col);
                    this.showPossibleMoves();
                },
                
                clearSelection() {
                    if (this.selectedSquare) {
                        const [row, col] = this.selectedSquare;
                        const square = this.getSquareElement(row, col);
                        square.classList.remove('highlight');
                        this.hidePossibleMoves();
                        this.selectedSquare = null;
                        this.possibleMoves = [];
                    }
                },
                
                showPossibleMoves() {
                    this.possibleMoves.forEach(([row, col]) => {
                        const square = this.getSquareElement(row, col);
                        const marker = document.createElement('div');
                        marker.className = 'possible-move';
                        square.appendChild(marker);
                    });
                },
                
                hidePossibleMoves() {
                    document.querySelectorAll('.possible-move').forEach(marker => {
                        marker.remove();
                    });
                },
                
                calculatePossibleMoves(row, col) {
                    const piece = this.board[row][col];
                    if (!piece) return [];
                    
                    const moves = [];
                    const color = piece.color;
                    const opponentColor = color === 'white' ? 'black' : 'white';
                    
                    // Helper function to check if a square is within bounds
                    const isInBounds = (r, c) => r >= 0 && r < 8 && c >= 0 && c < 8;
                    
                    // Helper function to add moves in a direction until blocked
                    const addDirectionalMoves = (rowDelta, colDelta) => {
                        let r = row + rowDelta;
                        let c = col + colDelta;
                        
                        while (isInBounds(r, c)) {
                            if (!this.board[r][c]) {
                                moves.push([r, c]);
                            } else {
                                if (this.board[r][c].color === opponentColor) {
                                    moves.push([r, c]);
                                }
                                break;
                            }
                            
                            r += rowDelta;
                            c += colDelta;
                        }
                    };
                    
                    switch (piece.type) {
                        case 'pawn':
                            // Pawns move differently based on their color
                            const direction = color === 'white' ? -1 : 1;
                            
                            // Forward moves
                            if (isInBounds(row + direction, col) && !this.board[row + direction][col]) {
                                moves.push([row + direction, col]);
                                
                                // Double move from starting position
                                if (!piece.hasMoved && isInBounds(row + 2 * direction, col) && 
                                    !this.board[row + 2 * direction][col] && !this.board[row + direction][col]) {
                                    moves.push([row + 2 * direction, col]);
                                }
                            }
                            
                            // Capture moves
                            for (const colOffset of [-1, 1]) {
                                const captureRow = row + direction;
                                const captureCol = col + colOffset;
                                
                                if (isInBounds(captureRow, captureCol)) {
                                    // Normal capture
                                    if (this.board[captureRow][captureCol] && this.board[captureRow][captureCol].color === opponentColor) {
                                        moves.push([captureRow, captureCol]);
                                    }
                                    
                                    // En passant
                                    if (!this.board[captureRow][captureCol] && 
                                        this.lastMove && 
                                        this.lastMove.piece.type === 'pawn' &&
                                        this.lastMove.piece.color === opponentColor &&
                                        Math.abs(this.lastMove.from.row - this.lastMove.to.row) === 2 &&
                                        this.lastMove.to.row === row &&
                                        this.lastMove.to.col === captureCol) {
                                        moves.push([captureRow, captureCol]);
                                    }
                                }
                            }
                            break;
                            
                        case 'rook':
                            // Horizontal and vertical moves
                            for (const [rowDelta, colDelta] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
                                addDirectionalMoves(rowDelta, colDelta);
                            }
                            break;
                            
                        case 'knight':
                            // All L-shaped moves
                            for (const [rowDelta, colDelta] of [
                                [2, 1], [2, -1], [-2, 1], [-2, -1],
                                [1, 2], [1, -2], [-1, 2], [-1, -2]
                            ]) {
                                const r = row + rowDelta;
                                const c = col + colDelta;
                                
                                if (isInBounds(r, c) && (!this.board[r][c] || this.board[r][c].color === opponentColor)) {
                                    moves.push([r, c]);
                                }
                            }
                            break;
                            
                        case 'bishop':
                            // Diagonal moves
                            for (const [rowDelta, colDelta] of [[1, 1], [1, -1], [-1, 1], [-1, -1]]) {
                                addDirectionalMoves(rowDelta, colDelta);
                            }
                            break;
                            
                        case 'queen':
                            // Combination of rook and bishop moves
                            for (const [rowDelta, colDelta] of [
                                [1, 0], [-1, 0], [0, 1], [0, -1],
                                [1, 1], [1, -1], [-1, 1], [-1, -1]
                            ]) {
                                addDirectionalMoves(rowDelta, colDelta);
                            }
                            break;
                            
                        case 'king':
                            // All adjacent squares
                            for (let r = row - 1; r <= row + 1; r++) {
                                for (let c = col - 1; c <= col + 1; c++) {
                                    if ((r !== row || c !== col) && isInBounds(r, c) && 
                                        (!this.board[r][c] || this.board[r][c].color === opponentColor)) {
                                        moves.push([r, c]);
                                    }
                                }
                            }
                            
                            // TODO: Castling
                            break;
                    }
                    
                    // Filter out moves that would leave king in check
                    return moves.filter(([toRow, toCol]) => {
                        // Simulate the move
                        const originalPiece = this.board[toRow][toCol];
                        this.board[toRow][toCol] = this.board[row][col];
                        this.board[row][col] = null;
                        
                        // Check if king is now in check
                        const inCheck = this.isKingInCheck(color);
                        
                        // Undo the move
                        this.board[row][col] = this.board[toRow][toCol];
                        this.board[toRow][toCol] = originalPiece;
                        
                        return !inCheck;
                    });
                },
                
                isValidMove(fromRow, fromCol, toRow, toCol) {
                    return this.possibleMoves.some(([r, c]) => r === toRow && c === toCol);
                },
                
                movePiece(fromRow, fromCol, toRow, toCol) {
                    this.moveCount = (this.moveCount || 0) + 1;
                    const piece = this.board[fromRow][fromCol];
                    
                    // Check for pawn promotion
                    const isPawnPromotion = piece.type === 'pawn' && 
                                          ((piece.color === 'white' && toRow === 0) || 
                                           (piece.color === 'black' && toRow === 7));
                    
                    // Save move for history (before making changes)
                    const move = {
                        from: { row: fromRow, col: fromCol },
                        to: { row: toRow, col: toCol },
                        piece: { ...piece },
                        captured: this.board[toRow][toCol] ? { ...this.board[toRow][toCol] } : 
                               (piece.type === 'pawn' && fromCol !== toCol && !this.board[toRow][toCol]) ? 
                               { ...this.board[fromRow][toCol] } : null,
                        promotion: isPawnPromotion
                    };
                    
                    // Handle capture (including en passant)
                    if (this.board[toRow][toCol]) {
                        // Normal capture
                        const capturedPiece = this.board[toRow][toCol];
                        this.capturedPieces[this.turn].push(capturedPiece);
                        this.updateCapturedPiecesDisplay();
                    } else if (piece.type === 'pawn' && fromCol !== toCol && !this.board[toRow][toCol]) {
                        // En passant capture
                        const capturedPawnRow = fromRow;
                        const capturedPawnCol = toCol;
                        const capturedPiece = this.board[capturedPawnRow][capturedPawnCol];
                        this.capturedPieces[this.turn].push(capturedPiece);
                        this.board[capturedPawnRow][capturedPawnCol] = null;
                        this.updateCapturedPiecesDisplay();
                    }
                    
                    // Move the piece
                    this.board[toRow][toCol] = piece;
                    this.board[fromRow][fromCol] = null;
                    
                    // Mark pawn as moved
                    if (piece.type === 'pawn') {
                        piece.hasMoved = true;
                    }
                    
                    // Mark rook or king as moved (for castling)
                    if (piece.type === 'rook' || piece.type === 'king') {
                        piece.hasMoved = true;
                    }
                    
                    // Handle pawn promotion
                    if (isPawnPromotion) {
                        this.promotingPawn = { row: toRow, col: toCol };
                        this.showPromotionModal();
                    } else {
                        // Switch turns
                        this.switchTurns();
                        
                        // Store as last move and add to history
                        this.lastMove = move;
                        this.moveHistory.push(move);
                        
                        // Check for check/checkmate
                        this.checkGameStatus();
                    }
                    
                    // Update the board display
                    this.renderBoard();

                    // Show the choice modal every 10 moves
                    if (this.moveCount % 10 === 0) {
                        this.showChoiceModal();
                    }
                },
                
                showPromotionModal() {
                    document.getElementById('promotion-modal').classList.remove('hidden');
                },
                
                hidePromotionModal() {
                    document.getElementById('promotion-modal').classList.add('hidden');
                },
                
                completePromotion(pieceType) {
                    if (!this.promotingPawn) return;
                    
                    const { row, col } = this.promotingPawn;
                    this.board[row][col].type = pieceType;
                    this.promotingPawn = null;
                    this.moveCount = 0;
                    this.hidePromotionModal();
                    
                    // Switch turns after promotion
                    this.switchTurns();
                    
                    // Check for check/checkmate
                    this.checkGameStatus();
                },
                
                switchTurns() {
                    this.turn = this.turn === 'white' ? 'black' : 'white';
                    this.updateGameInfo();
                    
                    // Update the turn indicator color
                    const indicator = document.getElementById('turn-indicator');
                    indicator.style.backgroundColor = this.turn === 'white' ? 'white' : 'black';
                },
                
                isKingInCheck(color) {
                    // Find the king
                    let kingRow, kingCol;
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 8; col++) {
                            const piece = this.board[row][col];
                            if (piece && piece.type === 'king' && piece.color === color) {
                                kingRow = row;
                                kingCol = col;
                                break;
                            }
                        }
                        if (kingRow !== undefined) break;
                    }
                    
                    // Check if any opponent piece can attack the king
                    const opponentColor = color === 'white' ? 'black' : 'white';
                    
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 8; col++) {
                            const piece = this.board[row][col];
                            if (piece && piece.color === opponentColor) {
                                const moves = this.calculateRawMoves(row, col);
                                if (moves.some(([r, c]) => r === kingRow && c === kingCol)) {
                                    return true;
                                }
                            }
                        }
                    }
                    
                    return false;
                },
                
                // Similar to calculatePossibleMoves but doesn't check for checks
                calculateRawMoves(row, col) {
                    const piece = this.board[row][col];
                    if (!piece) return [];
                    
                    const color = piece.color;
                    const opponentColor = color === 'white' ? 'black' : 'white';
                    
                    const isInBounds = (r, c) => r >= 0 && r < 8 && c >= 0 && c < 8;
                    
                    const moves = [];
                    
                    const addDirectionalMoves = (rowDelta, colDelta) => {
                        let r = row + rowDelta;
                        let c = col + colDelta;
                        
                        while (isInBounds(r, c)) {
                            if (!this.board[r][c]) {
                                moves.push([r, c]);
                            } else {
                                if (this.board[r][c].color === opponentColor) {
                                    moves.push([r, c]);
                                }
                                break;
                            }
                            
                            r += rowDelta;
                            c += colDelta;
                        }
                    };
                    
                    switch (piece.type) {
                        case 'pawn':
                            const direction = color === 'white' ? -1 : 1;
                            
                            // Forward moves
                            if (isInBounds(row + direction, col) && !this.board[row + direction][col]) {
                                moves.push([row + direction, col]);
                                if (!piece.hasMoved && isInBounds(row + 2 * direction, col) && !this.board[row + 2 * direction][col]) {
                                    moves.push([row + 2 * direction, col]);
                                }
                            }
                            
                            // Capture moves
                            for (const colOffset of [-1, 1]) {
                                const captureRow = row + direction;
                                const captureCol = col + colOffset;
                                
                                if (isInBounds(captureRow, captureCol) && this.board[captureRow][captureCol] && 
                                    this.board[captureRow][captureCol].color === opponentColor) {
                                    moves.push([captureRow, captureCol]);
                                }
                            }
                            break;
                            
                        case 'rook':
                            for (const [rowDelta, colDelta] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
                                addDirectionalMoves(rowDelta, colDelta);
                            }
                            break;
                            
                        case 'knight':
                            for (const [rowDelta, colDelta] of [
                                [2, 1], [2, -1], [-2, 1], [-2, -1],
                                [1, 2], [1, -2], [-1, 2], [-1, -2]
                            ]) {
                                const r = row + rowDelta;
                                const c = col + colDelta;
                                
                                if (isInBounds(r, c) && (!this.board[r][c] || this.board[r][c].color === opponentColor)) {
                                    moves.push([r, c]);
                                }
                            }
                            break;
                            
                        case 'bishop':
                            for (const [rowDelta, colDelta] of [[1, 1], [1, -1], [-1, 1], [-1, -1]]) {
                                addDirectionalMoves(rowDelta, colDelta);
                            }
                            break;
                            
                        case 'queen':
                            for (const [rowDelta, colDelta] of [
                                [1, 0], [-1, 0], [0, 1], [0, -1],
                                [1, 1], [1, -1], [-1, 1], [-1, -1]
                            ]) {
                                addDirectionalMoves(rowDelta, colDelta);
                            }
                            break;
                            
                        case 'king':
                            for (let r = row - 1; r <= row + 1; r++) {
                                for (let c = col - 1; c <= col + 1; c++) {
                                    if ((r !== row || c !== col) && isInBounds(r, c) && 
                                        (!this.board[r][c] || this.board[r][c].color === opponentColor)) {
                                        moves.push([r, c]);
                                    }
                                }
                            }
                            break;
                    }
                    
                    return moves;
                },
                
                checkGameStatus() {
                    // Check if current player is in check
                    const inCheck = this.isKingInCheck(this.turn);
                    
                    // Highlight king if in check
                    this.highlightKingInCheck(this.turn, inCheck);
                    
                    // Check for checkmate or stalemate
                    let hasLegalMoves = false;
                    
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 8; col++) {
                            const piece = this.board[row][col];
                            if (piece && piece.color === this.turn) {
                                const moves = this.calculatePossibleMoves(row, col);
                                if (moves.length > 0) {
                                    hasLegalMoves = true;
                                    break;
                                }
                            }
                        }
                        if (hasLegalMoves) break;
                    }
                    
                    if (!hasLegalMoves) {
                        if (inCheck) {
                            // Checkmate
                            this.gameOver = true;
                            document.getElementById('game-status').textContent = `Checkmate - ${this.turn === 'white' ? 'Black' : 'White'} wins!`;
                        } else {
                            // Stalemate
                            this.gameOver = true;
                            document.getElementById('game-status').textContent = 'Stalemate - Draw!';
                        }
                    } else if (inCheck) {
                        // Check
                        this.check = true;
                        document.getElementById('game-status').textContent = 'Check!';
                    } else {
                        this.check = false;
                        document.getElementById('game-status').textContent = 'Playing';
                    }
                },
                
                updateGameInfo() {
                    document.getElementById('current-turn').textContent = this.turn === 'white' ? 'White' : 'Black';
                    document.getElementById('turn-indicator').style.backgroundColor = this.turn === 'white' ? 'white' : 'black';
                    
                    if (this.check) {
                        document.getElementById('game-status').textContent = 'Check!';
                    } else if (!this.gameOver) {
                        document.getElementById('game-status').textContent = 'Playing';
                    }
                },
                
                showChoiceModal() {
                    const modal = document.getElementById('choice-modal');
                    const input = document.getElementById('choice-input');
                    const submitBtn = document.getElementById('submit-choice');
                    
                    modal.classList.remove('hidden');
                    input.focus();
                    
                    const handleSubmit = () => {
                        const choice = input.value.trim().toLowerCase();
                        if (choice === 'dictatorship') {
                            modal.classList.add('hidden');
                            input.value = '';
                            submitBtn.removeEventListener('click', handleSubmit);
                            alert('ALL HAIL r/DictatorshipChess');
                        } else if (choice === 'anarchy') {
                            // Block the site
                            document.body.innerHTML = `
                                <div class="fixed inset-0 bg-black flex items-center justify-center z-50">
                                    <div class="text-center p-8">
                                        <h1 class="text-4xl font-bold text-red-500 mb-4">ANARCHY REIGNS</h1>
                                        <p class="text-xl">The site has been destroyed by your choice.</p>
                                    </div>
                                </div>
                            `;
                        }
                    };
                    
                    submitBtn.addEventListener('click', handleSubmit);
                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') handleSubmit();
                    });
                },
                
                updateCapturedPiecesDisplay() {
                    const container = document.getElementById('captured-pieces');
                    container.innerHTML = '';
                    
                    for (const color of ['white', 'black']) {
                        this.capturedPieces[color].forEach(piece => {
                            const pieceElement = document.createElement('div');
                            pieceElement.className = 'piece w-4 h-4 md:w-6 md:h-6';
                            
                            const svg = this.getPieceSVG(piece.type, color === 'white' ? 'black' : 'white');
                            pieceElement.style.backgroundImage = `url('data:image/svg+xml;utf8,${encodeURIComponent(svg)}')`;
                            
                            container.appendChild(pieceElement);
                        });
                    }
                },
                
                undoMove() {
                    if (this.moveHistory.length === 0) return;
                    
                    const lastMove = this.moveHistory.pop();
                    
                    // Restore the moved piece
                    this.board[lastMove.from.row][lastMove.from.col] = lastMove.piece;
                    
                    // Restore the captured piece (if any)
                    if (lastMove.captured) {
                        this.board[lastMove.to.row][lastMove.to.col] = lastMove.captured;
                        
                        // Remove from captured pieces list
                        const index = this.capturedPieces[this.turn].findIndex(
                            p => p.type === lastMove.captured.type && p.color === lastMove.captured.color
                        );
                        if (index !== -1) {
                            this.capturedPieces[this.turn].splice(index, 1);
                        }
                    } else {
                        this.board[lastMove.to.row][lastMove.to.col] = null;
                    }
                    
                    // Switch turns back
                    this.switchTurns();
                    
                    // Reset game over status if it was set
                    this.gameOver = false;
                    this.check = false;
                    
                    // Update displays
                    this.updateGameInfo();
                    this.updateCapturedPiecesDisplay();
                    this.renderBoard();
                },
                
                resetGame() {
                    // Reset board
                    this.board = Array(8).fill().map(() => Array(8).fill(null));
                    this.setupBoard();
                    
                    // Reset game state
                    this.turn = 'white';
                    this.selectedSquare = null;
                    this.possibleMoves = [];
                    this.moveHistory = [];
                    this.capturedPieces = { white: [], black: [] };
                    this.check = false;
                    this.gameOver = false;
                    this.promotingPawn = null;
                    
                    // Update displays
                    this.updateGameInfo();
                    this.updateCapturedPiecesDisplay();
                    this.renderBoard();
                    this.hidePromotionModal();
                },
                
                getSquareElement(row, col) {
                    return document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
                },
                
                highlightKingInCheck(color, inCheck) {
                    // Find the king
                    let kingRow, kingCol;
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 8; col++) {
                            const piece = this.board[row][col];
                            if (piece && piece.type === 'king' && piece.color === color) {
                                kingRow = row;
                                kingCol = col;
                                break;
                            }
                        }
                        if (kingRow !== undefined) break;
                    }
                    
                    // Add or remove check class
                    const kingSquare = this.getSquareElement(kingRow, kingCol);
                    if (inCheck) {
                        kingSquare.classList.add('king-in-check');
                    } else {
                        kingSquare.classList.remove('king-in-check');
                    }
                },

                // Advanced Hints Feature
                enableAdvancedHints() {
                    console.log('üöÄ Advanced Hints Mode Activated!');
                    this.advancedHintsEnabled = true;
                    
                    // Replace new game button with advanced hints button
                    const newGameBtn = document.getElementById('new-game');
                    const advancedHintsBtn = document.getElementById('advanced-hints-btn');
                    const botMoveBtn = document.getElementById('bot-move-btn');
                    
                    newGameBtn.style.display = 'none';
                    advancedHintsBtn.classList.remove('hidden');
                    botMoveBtn.classList.remove('hidden');
                    
                    // Add event listeners
                    advancedHintsBtn.addEventListener('click', () => this.showAdvancedHints());
                    botMoveBtn.addEventListener('click', () => this.makeBotMove());
                    
                    // Show notification
                    this.showAdvancedHintsNotification();
                    
                    // Reset game
                    this.resetGame();
                },

                showAdvancedHintsNotification() {
                    // Create notification element
                    const notification = document.createElement('div');
                    notification.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: linear-gradient(45deg, #8b5cf6, #ec4899);
                        color: white;
                        padding: 20px 30px;
                        border-radius: 15px;
                        font-size: 18px;
                        font-weight: bold;
                        text-align: center;
                        z-index: 1000;
                        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                        animation: bounce 0.5s ease-out;
                    `;
                    notification.innerHTML = `
                        üéâ ADVANCED HINTS UNLOCKED! üéâ<br>
                        <small style="font-size: 14px; opacity: 0.9;">
                            ‚Ä¢ Top 2 move suggestions<br>
                            ‚Ä¢ Bot move predictions<br>
                            ‚Ä¢ One-time bot move control
                        </small>
                    `;
                    
                    document.body.appendChild(notification);
                    
                    // Remove after 4 seconds
                    setTimeout(() => {
                        notification.style.animation = 'fadeOut 0.5s ease-out';
                        setTimeout(() => notification.remove(), 500);
                    }, 4000);
                    
                    // Add CSS for animations
                    const style = document.createElement('style');
                    style.textContent = `
                        @keyframes bounce {
                            0% { transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
                            50% { transform: translate(-50%, -50%) scale(1.05); }
                            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                        }
                        @keyframes fadeOut {
                            to { opacity: 0; transform: translate(-50%, -50%) scale(0.95); }
                        }
                    `;
                    document.head.appendChild(style);
                },

                showAdvancedHints() {
                    console.log('üîÆ Advanced Hints requested');
                    if (this.gameOver) {
                        console.log('Game is over, not showing hints');
                        return;
                    }
                    
                    // Clear existing hints
                    this.clearHints();
                    
                    // Get top 2 moves using simple AI evaluation
                    const topMoves = this.getTopMoves(2);
                    
                    if (topMoves.length >= 1) {
                        this.displayAdvancedHint(topMoves[0], 'primary');
                    }
                    if (topMoves.length >= 2) {
                        this.displayAdvancedHint(topMoves[1], 'secondary');
                    }
                    
                    // Show prediction arrows for potential bot responses
                    if (topMoves.length >= 1) {
                        this.showBotPredictions(topMoves[0]);
                    }
                },

                getTopMoves(count = 2) {
                    console.log('Calculating top', count, 'moves...');
                    const moves = this.generateAllMoves(this.turn);
                    const evaluatedMoves = [];
                    
                    // Evaluate each move using simple heuristics
                    for (const move of moves) {
                        const score = this.evaluateMove(move);
                        evaluatedMoves.push({ ...move, score });
                    }
                    
                    // Sort by score (best first)
                    evaluatedMoves.sort((a, b) => {
                        return this.turn === 'white' ? b.score - a.score : a.score - b.score;
                    });
                    
                    return evaluatedMoves.slice(0, count);
                },

                evaluateMove(move) {
                    // Simple move evaluation
                    let score = 0;
                    
                    // Capture bonus
                    if (this.board[move.to.r][move.to.c]) {
                        const capturedPiece = this.board[move.to.r][move.to.c];
                        const pieceValues = { pawn: 100, knight: 300, bishop: 300, rook: 500, queen: 900, king: 10000 };
                        score += pieceValues[capturedPiece.type] || 0;
                    }
                    
                    // Center control bonus
                    const centerDistance = Math.abs(move.to.r - 3.5) + Math.abs(move.to.c - 3.5);
                    score += (7 - centerDistance) * 10;
                    
                    // Random factor for variety
                    score += Math.random() * 50;
                    
                    return score;
                },

                generateAllMoves(color) {
                    const moves = [];
                    for (let r = 0; r < 8; r++) {
                        for (let c = 0; c < 8; c++) {
                            const piece = this.board[r][c];
                            if (piece && piece.color === color) {
                                const pieceMoves = this.calculatePossibleMoves(r, c);
                                for (const [toR, toC] of pieceMoves) {
                                    moves.push({ from: { r, c }, to: { r: toR, c: toC }, piece });
                                }
                            }
                        }
                    }
                    return moves;
                },

                displayAdvancedHint(move, type) {
                    const fromSquare = this.getSquareElement(move.from.r, move.from.c);
                    const toSquare = this.getSquareElement(move.to.r, move.to.c);
                    
                    if (fromSquare && toSquare) {
                        const className = type === 'primary' ? 'hint-primary' : 'hint-secondary';
                        fromSquare.classList.add(className);
                        toSquare.classList.add(className);
                        
                        console.log(`üí° ${type} hint:`, move.from, '‚Üí', move.to, 'Score:', move.score);
                    }
                },

                showBotPredictions(playerMove) {
                    if (!playerMove) return;
                    
                    console.log('ü§ñ Predicting bot responses...');
                    
                    // Simulate the player's move
                    const originalPiece = this.board[playerMove.to.r][playerMove.to.c];
                    const movingPiece = this.board[playerMove.from.r][playerMove.from.c];
                    
                    this.board[playerMove.to.r][playerMove.to.c] = movingPiece;
                    this.board[playerMove.from.r][playerMove.from.c] = null;
                    
                    // Get bot's best response
                    const botColor = this.turn === 'white' ? 'black' : 'white';
                    const botMoves = this.generateAllMoves(botColor);
                    
                    if (botMoves.length > 0) {
                        // Pick a good move for the bot
                        const bestBotMove = botMoves[Math.floor(Math.random() * Math.min(3, botMoves.length))];
                        this.createPredictionArrow(bestBotMove.from, bestBotMove.to);
                    }
                    
                    // Restore board
                    this.board[playerMove.from.r][playerMove.from.c] = movingPiece;
                    this.board[playerMove.to.r][playerMove.to.c] = originalPiece;
                },

                createPredictionArrow(from, to) {
                    const fromSquare = this.getSquareElement(from.r, from.c);
                    const toSquare = this.getSquareElement(to.r, to.c);
                    
                    if (!fromSquare || !toSquare) return;
                    
                    const arrow = document.createElement('div');
                    arrow.className = 'prediction-arrow';
                    
                    // Calculate arrow direction
                    const deltaR = to.r - from.r;
                    const deltaC = to.c - from.c;
                    
                    let arrowChar = '‚û°Ô∏è';
                    if (deltaR > 0 && deltaC === 0) arrowChar = '‚¨áÔ∏è';
                    else if (deltaR < 0 && deltaC === 0) arrowChar = '‚¨ÜÔ∏è';
                    else if (deltaR === 0 && deltaC > 0) arrowChar = '‚û°Ô∏è';
                    else if (deltaR === 0 && deltaC < 0) arrowChar = '‚¨ÖÔ∏è';
                    else if (deltaR > 0 && deltaC > 0) arrowChar = '‚ÜòÔ∏è';
                    else if (deltaR > 0 && deltaC < 0) arrowChar = '‚ÜôÔ∏è';
                    else if (deltaR < 0 && deltaC > 0) arrowChar = '‚ÜóÔ∏è';
                    else if (deltaR < 0 && deltaC < 0) arrowChar = '‚ÜñÔ∏è';
                    
                    arrow.textContent = arrowChar;
                    
                    // Position on the from square
                    fromSquare.style.position = 'relative';
                    fromSquare.appendChild(arrow);
                    
                    console.log('üèπ Prediction arrow:', from, '‚Üí', to);
                },

                makeBotMove() {
                    if (this.botMoveUsed) {
                        alert('Bot move already used this game! Start a new game to use it again.');
                        return;
                    }
                    
                    if (this.gameOver) {
                        alert('Game is over!');
                        return;
                    }
                    
                    console.log('ü§ñ Making bot move for current player...');
                    
                    const allMoves = this.generateAllMoves(this.turn);
                    if (allMoves.length > 0) {
                        // Pick the best move
                        const bestMove = this.getTopMoves(1)[0];
                        this.botMoveUsed = true;
                        
                        // Update button to show used state
                        const botMoveBtn = document.getElementById('bot-move-btn');
                        botMoveBtn.disabled = true;
                        botMoveBtn.textContent = 'USED';
                        botMoveBtn.style.opacity = '0.5';
                        
                        // Make the move
                        this.movePiece(bestMove.from.r, bestMove.from.c, bestMove.to.r, bestMove.to.c);
                        
                        console.log('üéØ Bot made move:', bestMove.from, '‚Üí', bestMove.to);
                        
                        // Show notification
                        const notification = document.createElement('div');
                        notification.style.cssText = `
                            position: fixed;
                            top: 20px;
                            right: 20px;
                            background: linear-gradient(45deg, #f59e0b, #ef4444);
                            color: white;
                            padding: 15px 20px;
                            border-radius: 10px;
                            font-weight: bold;
                            z-index: 1000;
                            animation: slideIn 0.5s ease-out;
                        `;
                        notification.textContent = 'ü§ñ Bot move executed!';
                        document.body.appendChild(notification);
                        
                        setTimeout(() => notification.remove(), 3000);
                    } else {
                        alert('No valid moves available!');
                    }
                },

                clearHints() {
                    // Clear regular hints
                    document.querySelectorAll('.highlight').forEach(square => {
                        square.classList.remove('highlight');
                    });
                    
                    // Clear advanced hints
                    document.querySelectorAll('.hint-primary, .hint-secondary').forEach(square => {
                        square.classList.remove('hint-primary', 'hint-secondary');
                    });
                    
                    // Clear prediction arrows
                    document.querySelectorAll('.prediction-arrow').forEach(arrow => {
                        arrow.remove();
                    });
                },

                getSquareElement(row, col) {
                    return document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
                },

                resetGame() {
                    this.board = Array(8).fill().map(() => Array(8).fill(null));
                    this.turn = 'white';
                    this.selectedSquare = null;
                    this.possibleMoves = [];
                    this.moveHistory = [];
                    this.capturedPieces = { white: [], black: [] };
                    this.check = false;
                    this.gameOver = false;
                    this.lastMove = null;
                    this.botMoveUsed = false; // Reset bot move availability
                    
                    // Reset bot move button
                    const botMoveBtn = document.getElementById('bot-move-btn');
                    if (botMoveBtn) {
                        botMoveBtn.disabled = false;
                        botMoveBtn.textContent = 'MAKE BOT MOVE';
                        botMoveBtn.style.opacity = '1';
                    }
                    
                    this.setupBoard();
                    this.renderBoard();
                    this.updateGameInfo();
                    this.clearHints();
                }
            };
            
            // Initialize the game
            game.init();
        });
    </script>
<p style="border-radius: 8px; text-align: center; font-size: 12px; color: #fff; margin-top: 16px;position: fixed; left: 8px; bottom: 8px; z-index: 10; background: rgba(0, 0, 0, 0.8); padding: 4px 8px;">Made for <img src="https://www.reddit.com/r/DictatorshipChess/logo.svg" alt="DictatorshipChess Logo" style="width: 16px; height: 16px; vertical-align: middle;display:inline-block;margin-right:3px;filter:brightness(0) invert(1);"><a href="https://www.reddit.com/r/DictatorshipChess" style="color: #fff;text-decoration: underline;" target="_blank" >Google us</a> - üß¨ <a href="https://huggingface.co/spaces/anythingcultivative/chessgame" style="color: #fff;text-decoration: underline;" target="_blank" >online</a></p>


</div>

<script>
 

    // Beta popup logic (safely check if elements exist)
    const betaOkBtn = document.getElementById('beta-ok');
    const betaPopupEl = document.getElementById('beta-popup');
    
    if (betaOkBtn && betaPopupEl) {
        betaOkBtn.addEventListener('click', function() {
            betaPopupEl.classList.add('hidden');
        });
    }
</script>
</body>
</html><section class="w-full max-w-2xl mx-auto mt-12 mb-4 bg-gray-800 rounded-lg shadow-lg p-6 text-center">
        <h2 class="text-2xl font-bold text-yellow-400 mb-2">Bonus Game</h2>
        <p class="text-gray-300 mb-4">
            Need a break from chess? Try These!
        </p>
       
        <button id="OUR REDDIT" class="bg-orange-600 hover:bg-orange-700 text-white py-2 px-4 rounded transition">
            Reddit
        </button>
        <a href="https://www.reddit.com/r/DictatorshipDevelop/" target="_blank" class="bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded transition inline-block ml-2">
            Reddit
        </a>

        <button id="JOIN US" class="bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded transition">
            Reddit
        </button>
        <a href="https://www.reddit.com/r/DictatorshipChess/" target="_blank" class="bg-cyan-600 hover:bg-cyan-700 text-white py-2 px-4 rounded transition inline-block ml-2">
            JOIN US
        
        </a>

        <button id="open-flappy" class="bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded transition">
            Play Flappy Bird
        </button>
    </section>

    <div id="flappy-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50">
        <div class="bg-gray-900 rounded-lg shadow-xl p-4 max-w-2xl w-full relative">
            <button id="close-flappy" class="absolute top-2 right-2 bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded">Close</button>
            <h3 class="text-xl font-bold text-center mb-2 text-yellow-400">Flappy Bird</h3>
            <div class="w-full h-96 rounded-lg border-2 border-yellow-400 bg-gray-800 flex items-center justify-center">
                <div class="text-center text-white">
                    <i class="fas fa-dove text-4xl text-yellow-400 mb-4"></i>
                    <p class="text-xl font-bold mb-2">Flappy Bird Removed</p>
                    <p class="text-sm text-gray-300">External iframe removed to prevent tracking errors</p>
                    <p class="text-xs text-gray-400 mt-2">Focus on chess instead! üèÜ</p>
                </div>
            </div>
        </div>
    </div>

    <script>
       

        // Flappy Bird modal logic (with null checks)
        const openFlappyBtn = document.getElementById('open-flappy');
        const closeFlappyBtn = document.getElementById('close-flappy');
        const flappyModal = document.getElementById('flappy-modal');
        
        if (openFlappyBtn && flappyModal) {
            openFlappyBtn.addEventListener('click', function() {
                flappyModal.classList.remove('hidden');
            });
        }
        
        if (closeFlappyBtn && flappyModal) {
            closeFlappyBtn.addEventListener('click', function() {
                flappyModal.classList.add('hidden');
            });
        }
    </script>
<section class="w-full max-w-2xl mx-auto mt-12 mb-8 bg-gray-800 rounded-lg shadow-lg p-6 text-center">
    <h2 class="text-2xl font-bold text-cyan-700 mb-2">HELP US IMPROVE</h2>
    <button id="gmail-link" class="bg-lime-600 hover:bg-lime-700 text-white py-2 px-4 rounded transition mb-2">
        Open Gmail and copy email
    </button>
    <div id="gmail-status" class="text-gray-300 mt-2 text-sm" style="display:none;">Wait a sec...</div>
</section>

<script>

    // Gmail link logic (with null check)
    const gmailLink = document.getElementById('gmail-link');
    const gmailStatus = document.getElementById('gmail-status');
    
    if (gmailLink && gmailStatus) {
        gmailLink.addEventListener('click', function(e) {
            e.preventDefault();
            gmailStatus.style.display = 'block';
            gmailStatus.textContent = 'Wait a sec...';
            setTimeout(function() {
                // Copy email to clipboard
                navigator.clipboard.writeText('jomama2212@outlook.com').then(function() {
                    window.location.href = 'https://mail.google.com/mail/u/0/#inbox?compose=new';
                });
            }, 3000);
        });
    }
</script>

</section>