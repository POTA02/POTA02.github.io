<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Revolutionary Chess - Rise of the Pieces</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
        }
        
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 1px;
            background: #2c1810;
            border: 4px solid #8b4513;
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        .chess-square {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
            border-radius: 4px;
        }
        
        .chess-square.light {
            background: linear-gradient(135deg, #f0d9b5, #e8c896);
        }
        
        .chess-square.dark {
            background: linear-gradient(135deg, #b58863, #9e6f46);
        }
        
        .chess-square.selected {
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            border: 3px solid #ffd700;
        }
        
        .chess-square.possible-move {
            background: radial-gradient(circle, rgba(0,255,0,0.3), transparent);
        }
        
        .chess-square.revolutionary-zone {
            background: radial-gradient(circle, rgba(255,0,0,0.2), transparent);
            animation: revolutionPulse 2s infinite;
        }
        
        @keyframes revolutionPulse {
            0%, 100% { box-shadow: 0 0 5px rgba(255,0,0,0.3); }
            50% { box-shadow: 0 0 20px rgba(255,0,0,0.8); }
        }
        
        .chess-piece {
            font-size: 2.5rem;
            user-select: none;
            transition: all 0.3s ease;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }
        
        .piece-svg {
            width: 80%;
            height: 80%;
            max-width: 50px;
            max-height: 50px;
            transition: all 0.3s ease;
        }
        
        .chess-piece:hover .piece-svg {
            transform: scale(1.1);
            filter: drop-shadow(0 0 10px rgba(255,215,0,0.6));
        }
        
        .chess-piece.revolutionary .piece-svg {
            animation: revolutionaryGlow 3s infinite;
        }
        
        @keyframes revolutionaryGlow {
            0%, 100% { filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3)); }
            50% { filter: drop-shadow(0 0 15px rgba(255,0,0,0.8)); }
        }
        
        .status-panel {
            background: rgba(0,0,0,0.8);
            border-radius: 10px;
            padding: 20px;
            color: white;
            backdrop-filter: blur(10px);
        }
        
        .revolution-meter {
            height: 20px;
            background: linear-gradient(90deg, #ff0000, #ff6600, #ffaa00);
            border-radius: 10px;
            transition: width 0.5s ease;
        }
        
        .ability-button {
            background: linear-gradient(135deg, #ff4757, #ff3838);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        
        .ability-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255,71,87,0.4);
        }
        
        .ability-button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            z-index: 1000;
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }
        
        .notification.show {
            transform: translateX(0);
        }
    </style>
</head>
<body>
    <div class="container mx-auto p-4">
        <div class="text-center mb-6">
            <h1 class="text-4xl font-bold text-white mb-2">
                <i class="fas fa-fist-raised text-red-500"></i>
                Revolutionary Chess
            </h1>
            <p class="text-xl text-gray-200">Rise up! Overthrow the monarchy!</p>
        </div>
        
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Game Board -->
            <div class="lg:col-span-2">
                <div class="chess-board w-full max-w-2xl mx-auto" id="chess-board">
                    <!-- Board squares will be generated by JavaScript -->
                </div>
            </div>
            
            <!-- Game Status Panel -->
            <div class="status-panel">
                <h2 class="text-2xl font-bold mb-4">
                    <i class="fas fa-crown text-yellow-400"></i>
                    Game Status
                </h2>
                
                <div class="mb-4">
                    <p class="text-lg mb-2">Current Turn: <span id="current-turn" class="font-bold">White</span></p>
                    <p class="text-sm text-gray-300">Move: <span id="move-count">1</span></p>
                    <p id="easter-egg-status" class="text-xs text-yellow-400 mt-1" style="display: none;">
                        ðŸŽŠ Ultimate Revolution Active! ðŸŽŠ
                    </p>
                </div>
                
                <!-- Revolution Meter -->
                <div class="mb-6">
                    <h3 class="text-lg font-bold mb-2">
                        <i class="fas fa-fire text-red-500"></i>
                        Revolution Meter
                    </h3>
                    <div class="bg-gray-700 rounded-full h-6 mb-2">
                        <div id="revolution-meter" class="revolution-meter h-full" style="width: 0%"></div>
                    </div>
                    <p class="text-sm text-gray-300">Capture pieces to fuel the revolution!</p>
                </div>
                
                <!-- Revolutionary Abilities -->
                <div class="mb-6">
                    <h3 class="text-lg font-bold mb-3">
                        <i class="fas fa-bolt text-yellow-400"></i>
                        Revolutionary Powers
                    </h3>
                    
                    <button id="uprising-btn" class="ability-button w-full mb-2" disabled>
                        <i class="fas fa-users"></i>
                        Peasant Uprising (Cost: 15)
                    </button>
                    
                    <button id="overthrow-btn" class="ability-button w-full mb-2" disabled>
                        <i class="fas fa-crown"></i>
                        Overthrow King (Cost: 25)
                    </button>
                    
                    <button id="barricade-btn" class="ability-button w-full mb-2" disabled>
                        <i class="fas fa-shield-alt"></i>
                        Build Barricades (Cost: 13)
                    </button>
                </div>
                
                <!-- Game Rules -->
                <div class="text-sm text-gray-300">
                    <h4 class="font-bold mb-2">Revolutionary Rules:</h4>
                    <ul class="list-disc list-inside space-y-1">
                        <li>Pawns can promote to any piece at rank 6</li>
                        <li>Captured pieces fuel revolution meter</li>
                        <li>Revolution abilities unlock at certain thresholds</li>
                        <li>Kings can be "overthrown" instead of checkmated</li>
                        <li>Pieces in revolution zones gain special powers</li>
                    </ul>
                </div>
                
                <!-- Game Controls -->
                <div class="mt-6 space-y-2">
                    <button id="new-game-btn" class="w-full bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded">
                        <i class="fas fa-play"></i>
                        New Revolution
                    </button>
                    <button id="surrender-btn" class="w-full bg-red-600 hover:bg-red-700 text-white py-2 px-4 rounded">
                        <i class="fas fa-flag"></i>
                        Surrender
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Notification System -->
    <div id="notification" class="notification">
        <div id="notification-content"></div>
    </div>

    <script>
        class RevolutionaryChess {
            constructor() {
                this.board = this.initializeBoard();
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.moveCount = 1;
                this.revolutionMeter = { white: 0, black: 0 };
                this.gameOver = false;
                this.revolutionZones = [];
                this.barricades = [];
                
                // Easter egg: Surrender counter
                this.surrenderCount = parseInt(localStorage.getItem('revolutionarySurrenders') || '0');
                this.easterEggActive = false;
                
                this.pieceSymbols = {
                    'white': {
                        'king': this.createPieceSVG('king', 'white'),
                        'queen': this.createPieceSVG('queen', 'white'),
                        'rook': this.createPieceSVG('rook', 'white'),
                        'bishop': this.createPieceSVG('bishop', 'white'),
                        'knight': this.createPieceSVG('knight', 'white'),
                        'pawn': this.createPieceSVG('pawn', 'white')
                    },
                    'black': {
                        'king': this.createPieceSVG('king', 'black'),
                        'queen': this.createPieceSVG('queen', 'black'),
                        'rook': this.createPieceSVG('rook', 'black'),
                        'bishop': this.createPieceSVG('bishop', 'black'),
                        'knight': this.createPieceSVG('knight', 'black'),
                        'pawn': this.createPieceSVG('pawn', 'black')
                    }
                };
                
                this.initializeUI();
                this.bindEvents();
                this.updateDisplay();
            }
            
            createPieceSVG(pieceType, color) {
                const isWhite = color === 'white';
                const fillColor = isWhite ? '#f8f9fa' : '#1a1a1a';
                const strokeColor = isWhite ? '#2c3e50' : '#ecf0f1';
                const glowColor = isWhite ? '#ffd700' : '#ff6b6b';
                
                const svgTemplates = {
                    king: `<svg viewBox="0 0 45 45" class="piece-svg">
                        <defs>
                            <linearGradient id="kingGrad${color}" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:${fillColor};stop-opacity:1" />
                                <stop offset="100%" style="stop-color:${isWhite ? '#e8e8e8' : '#333'};stop-opacity:1" />
                            </linearGradient>
                            <filter id="glow${color}">
                                <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                                <feMerge> 
                                    <feMergeNode in="coloredBlur"/>
                                    <feMergeNode in="SourceGraphic"/>
                                </feMerge>
                            </filter>
                        </defs>
                        <g fill="url(#kingGrad${color})" stroke="${strokeColor}" stroke-width="1.5" filter="url(#glow${color})">
                            <path d="M22.5,11.63 L22.5,6 M20,8 L25,8 M22.5,25 C22.5,25 27,17.5 25.5,14.5 C25.5,14.5 24.5,12 22.5,12 C20.5,12 19.5,14.5 19.5,14.5 C18,17.5 22.5,25 22.5,25"/>
                            <path d="M11.5,37 C17,40.5 27,40.5 32.5,37 L32.5,30 C32.5,30 41.5,25.5 38.5,19.5 C34.5,13 25,16 22.5,23.5 L22.5,27 L22.5,23.5 C20,16 10.5,13 6.5,19.5 C3.5,25.5 12.5,30 12.5,30 L11.5,37z"/>
                            <path d="M20,8 L25,8 M20,9 L25,9" stroke="${glowColor}" stroke-width="0.5"/>
                            <circle cx="22.5" cy="8" r="1.5" fill="${glowColor}"/>
                        </g>
                    </svg>`,
                    
                    queen: `<svg viewBox="0 0 45 45" class="piece-svg">
                        <defs>
                            <linearGradient id="queenGrad${color}" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:${fillColor};stop-opacity:1" />
                                <stop offset="100%" style="stop-color:${isWhite ? '#e8e8e8' : '#333'};stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <g fill="url(#queenGrad${color})" stroke="${strokeColor}" stroke-width="1.5">
                            <circle cx="6" cy="12" r="2.75"/>
                            <circle cx="14" cy="9" r="2.75"/>
                            <circle cx="22.5" cy="8" r="2.75"/>
                            <circle cx="31" cy="9" r="2.75"/>
                            <circle cx="39" cy="12" r="2.75"/>
                            <path d="M9,26 C17.5,32.5 27.5,32.5 36,26 L38.5,13.5 L31,25 L30.7,10.9 L25.5,24.5 L22.5,10 L19.5,24.5 L14.3,10.9 L14,25 L6.5,13.5 L9,26z"/>
                            <path d="M9,26 C9,28 10.5,28 11.5,30 C12.5,31.5 12.5,31 12,33.5 C10.5,34.5 10.5,36 10.5,36 C9,37.5 11,38.5 11,38.5 C17.5,39.5 27.5,39.5 34,38.5 C34,38.5 35.5,37.5 34,36 C34,36 34.5,34.5 33,33.5 C32.5,31 32.5,31.5 33.5,30 C34.5,28 36,28 36,26 C27.5,32.5 17.5,32.5 9,26z"/>
                            <circle cx="22.5" cy="8" r="1" fill="${glowColor}"/>
                        </g>
                    </svg>`,
                    
                    rook: `<svg viewBox="0 0 45 45" class="piece-svg">
                        <defs>
                            <linearGradient id="rookGrad${color}" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:${fillColor};stop-opacity:1" />
                                <stop offset="100%" style="stop-color:${isWhite ? '#e8e8e8' : '#333'};stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <g fill="url(#rookGrad${color})" stroke="${strokeColor}" stroke-width="1.5">
                            <path d="M9,39 L36,39 L36,36 L9,36 L9,39z"/>
                            <path d="M12.5,32 L14,29.5 L31,29.5 L32.5,32 L12.5,32z"/>
                            <path d="M12,36 L12,32 L33,32 L33,36 L12,36z"/>
                            <path d="M14,29.5 L14,16.5 L31,16.5 L31,29.5 L14,29.5z"/>
                            <path d="M14,16.5 L11,14 L34,14 L31,16.5 L14,16.5z"/>
                            <path d="M11,14 L11,9 L15,9 L15,11 L20,11 L20,9 L25,9 L25,11 L30,11 L30,9 L34,9 L34,14 L11,14z"/>
                            <rect x="19" y="20" width="7" height="4" fill="${glowColor}" opacity="0.7"/>
                        </g>
                    </svg>`,
                    
                    bishop: `<svg viewBox="0 0 45 45" class="piece-svg">
                        <defs>
                            <linearGradient id="bishopGrad${color}" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:${fillColor};stop-opacity:1" />
                                <stop offset="100%" style="stop-color:${isWhite ? '#e8e8e8' : '#333'};stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <g fill="url(#bishopGrad${color})" stroke="${strokeColor}" stroke-width="1.5">
                            <path d="M9,36 C12.39,35.03 19.11,36.43 22.5,34 C25.89,36.43 32.61,35.03 36,36 C36,36 37.65,36.54 39,38 C38.32,38.97 37.35,38.99 36,38.5 C32.61,37.53 25.89,38.96 22.5,37.5 C19.11,38.96 12.39,37.53 9,38.5 C7.65,38.99 6.68,38.97 6,38 C7.35,36.54 9,36 9,36z"/>
                            <path d="M15,32 C17.5,34.5 27.5,34.5 30,32 C30.5,30.5 30,30 30,30 C30,27.5 27.5,26 27.5,26 C33,24.5 33.5,14.5 22.5,10.5 C11.5,14.5 12,24.5 17.5,26 C17.5,26 15,27.5 15,30 C15,30 14.5,30.5 15,32z"/>
                            <path d="M25,8 C25,8 24.5,6.5 22.5,6.5 C20.5,6.5 20,8 20,8 C20,8 20,10 20.5,10.5 C21,11 24,11 24.5,10.5 C25,10 25,8 25,8z"/>
                            <circle cx="22.5" cy="25" r="2" fill="${glowColor}" opacity="0.8"/>
                        </g>
                    </svg>`,
                    
                    knight: `<svg viewBox="0 0 45 45" class="piece-svg">
                        <defs>
                            <linearGradient id="knightGrad${color}" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:${fillColor};stop-opacity:1" />
                                <stop offset="100%" style="stop-color:${isWhite ? '#e8e8e8' : '#333'};stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <g fill="url(#knightGrad${color})" stroke="${strokeColor}" stroke-width="1.5">
                            <path d="M22,10 C32.5,11 38.5,18 38,39 L15,39 C15,30 25,32.5 23,18"/>
                            <path d="M24,18 C24.38,20.91 18.45,25.37 16,27 C13,29 13.18,31.34 11,31 C9.958,30.06 12.41,27.96 11,28 C10,28 11.19,29.23 10,30 C9,30 5.997,31 6,26 C6,24 12,14 12,14 C12,14 13.89,12.1 14,10.5 C13.27,9.506 13.5,8.5 13.5,7.5 C14.5,6.5 16.5,10 16.5,10 L18.5,10 C18.5,10 19.28,8.008 21,7 C22,7 22,10 22,10"/>
                            <path d="M9.5,25.5 C9.5,27.5 11,28.5 11,28.5" stroke="${glowColor}" stroke-width="1.5" fill="none"/>
                            <circle cx="17" cy="15" r="1.5" fill="${glowColor}"/>
                        </g>
                    </svg>`,
                    
                    pawn: `<svg viewBox="0 0 45 45" class="piece-svg">
                        <defs>
                            <linearGradient id="pawnGrad${color}" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:${fillColor};stop-opacity:1" />
                                <stop offset="100%" style="stop-color:${isWhite ? '#e8e8e8' : '#333'};stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <g fill="url(#pawnGrad${color})" stroke="${strokeColor}" stroke-width="1.5">
                            <path d="M22.5,9 C19.79,9 18,10.79 18,13.5 C18,16.21 19.79,18 22.5,18 C25.21,18 27,16.21 27,13.5 C27,10.79 25.21,9 22.5,9z"/>
                            <path d="M22.5,19 C20,19 18,21 18,23.5 C18,26 20,28 22.5,28 C25,28 27,26 27,23.5 C27,21 25,19 22.5,19z"/>
                            <path d="M9,36 C12.39,35.03 19.11,36.43 22.5,34 C25.89,36.43 32.61,35.03 36,36 C36,36 37.65,36.54 39,38 C38.32,38.97 37.35,38.99 36,38.5 C32.61,37.53 25.89,38.96 22.5,37.5 C19.11,38.96 12.39,37.53 9,38.5 C7.65,38.99 6.68,38.97 6,38 C7.35,36.54 9,36 9,36z"/>
                            <circle cx="22.5" cy="13.5" r="1" fill="${glowColor}" opacity="0.8"/>
                        </g>
                    </svg>`
                };
                
                return svgTemplates[pieceType] || '';
            }
            
            initializeBoard() {
                const board = Array(8).fill(null).map(() => Array(8).fill(null));
                
                // Set up pawns
                for (let col = 0; col < 8; col++) {
                    board[1][col] = { type: 'pawn', color: 'black', hasMoved: false };
                    board[6][col] = { type: 'pawn', color: 'white', hasMoved: false };
                }
                
                // Set up back ranks
                const pieces = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
                for (let col = 0; col < 8; col++) {
                    board[0][col] = { type: pieces[col], color: 'black', hasMoved: false };
                    board[7][col] = { type: pieces[col], color: 'white', hasMoved: false };
                }
                
                return board;
            }
            
            initializeUI() {
                const boardElement = document.getElementById('chess-board');
                boardElement.innerHTML = '';
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `chess-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.row = row;
                        square.dataset.col = col;
                        
                        // Mark revolution zones (center 4 squares)
                        if ((row === 3 || row === 4) && (col === 3 || col === 4)) {
                            square.classList.add('revolutionary-zone');
                            this.revolutionZones.push({row, col});
                        }
                        
                        boardElement.appendChild(square);
                    }
                }
            }
            
            bindEvents() {
                document.getElementById('chess-board').addEventListener('click', (e) => {
                    // Find the chess square, even if we clicked on a piece inside it
                    let target = e.target;
                    while (target && !target.classList.contains('chess-square')) {
                        target = target.parentElement;
                    }
                    
                    if (target && target.classList.contains('chess-square')) {
                        const row = parseInt(target.dataset.row);
                        const col = parseInt(target.dataset.col);
                        this.handleSquareClick(row, col);
                    }
                });
                
                document.getElementById('new-game-btn').addEventListener('click', () => {
                    this.newGame();
                });
                
                document.getElementById('surrender-btn').addEventListener('click', () => {
                    this.surrender();
                });
                
                document.getElementById('uprising-btn').addEventListener('click', () => {
                    this.useAbility('uprising');
                });
                
                document.getElementById('overthrow-btn').addEventListener('click', () => {
                    this.useAbility('overthrow');
                });
                
                document.getElementById('barricade-btn').addEventListener('click', () => {
                    this.useAbility('barricade');
                });
            }
            
            handleSquareClick(row, col) {
                if (this.gameOver) return;
                
                console.log(`Clicked square: ${row}, ${col}`); // Debug log
                
                if (this.selectedSquare) {
                    if (this.selectedSquare.row === row && this.selectedSquare.col === col) {
                        // Deselect
                        this.selectedSquare = null;
                        this.updateDisplay();
                        return;
                    }
                    
                    if (this.isValidMove(this.selectedSquare.row, this.selectedSquare.col, row, col)) {
                        this.makeMove(this.selectedSquare.row, this.selectedSquare.col, row, col);
                        this.selectedSquare = null;
                        this.switchTurn();
                        this.updateDisplay();
                        return;
                    } else {
                        // Invalid move, try to select new piece
                        this.selectedSquare = null;
                    }
                }
                
                const piece = this.board[row][col];
                console.log(`Piece at ${row}, ${col}:`, piece); // Debug log
                if (piece && piece.color === this.currentPlayer) {
                    this.selectedSquare = { row, col };
                    console.log(`Selected:`, this.selectedSquare); // Debug log
                    this.updateDisplay();
                }
            }
            
            isValidMove(fromRow, fromCol, toRow, toCol) {
                if (toRow < 0 || toRow >= 8 || toCol < 0 || toCol >= 8) return false;
                
                const piece = this.board[fromRow][fromCol];
                const targetPiece = this.board[toRow][toCol];
                
                if (!piece || piece.color !== this.currentPlayer) return false;
                if (targetPiece && targetPiece.color === this.currentPlayer) return false;
                
                // Check for barricades blocking the destination
                const hasBarricade = this.barricades.some(b => b.row === toRow && b.col === toCol && b.owner !== this.currentPlayer);
                if (hasBarricade) return false;
                
                console.log(`Checking move validity for ${piece.type} from ${fromRow},${fromCol} to ${toRow},${toCol}`);
                const isValid = this.isPieceValidMove(piece, fromRow, fromCol, toRow, toCol);
                console.log(`Move is ${isValid ? 'valid' : 'invalid'}`);
                
                return isValid;
            }
            
            isPieceValidMove(piece, fromRow, fromCol, toRow, toCol) {
                const rowDiff = toRow - fromRow;
                const colDiff = toCol - fromCol;
                const absRowDiff = Math.abs(rowDiff);
                const absColDiff = Math.abs(colDiff);
                
                console.log(`Validating move for ${piece.type} from ${fromRow},${fromCol} to ${toRow},${toCol}`); // Debug
                
                switch (piece.type) {
                    case 'pawn':
                        const direction = piece.color === 'white' ? -1 : 1;
                        const startRow = piece.color === 'white' ? 6 : 1;
                        
                        // Forward move
                        if (colDiff === 0) {
                            if (rowDiff === direction && !this.board[toRow][toCol]) return true;
                            if (fromRow === startRow && rowDiff === 2 * direction && !this.board[toRow][toCol]) return true;
                        } 
                        // Diagonal capture
                        else if (absColDiff === 1 && rowDiff === direction && this.board[toRow][toCol]) {
                            return true;
                        }
                        return false;
                        
                    case 'rook':
                        if (rowDiff === 0 || colDiff === 0) {
                            return this.isPathClear(fromRow, fromCol, toRow, toCol);
                        }
                        return false;
                        
                    case 'bishop':
                        if (absRowDiff === absColDiff) {
                            return this.isPathClear(fromRow, fromCol, toRow, toCol);
                        }
                        return false;
                        
                    case 'queen':
                        if (rowDiff === 0 || colDiff === 0 || absRowDiff === absColDiff) {
                            return this.isPathClear(fromRow, fromCol, toRow, toCol);
                        }
                        return false;
                        
                    case 'knight':
                        return (absRowDiff === 2 && absColDiff === 1) || (absRowDiff === 1 && absColDiff === 2);
                        
                    case 'king':
                        // Revolutionary rule: Kings can move 2 squares when in revolution zones
                        const inRevolutionZone = this.revolutionZones.some(zone => 
                            zone.row === fromRow && zone.col === fromCol
                        );
                        const maxDistance = inRevolutionZone ? 2 : 1;
                        return absRowDiff <= maxDistance && absColDiff <= maxDistance;
                }
                
                return false;
            }
            
            isPathClear(fromRow, fromCol, toRow, toCol) {
                const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
                const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;
                
                let currentRow = fromRow + rowStep;
                let currentCol = fromCol + colStep;
                
                while (currentRow !== toRow || currentCol !== toCol) {
                    if (this.board[currentRow][currentCol]) return false;
                    currentRow += rowStep;
                    currentCol += colStep;
                }
                
                return true;
            }
            
            makeMove(fromRow, fromCol, toRow, toCol) {
                const piece = this.board[fromRow][fromCol];
                const capturedPiece = this.board[toRow][toCol];
                
                // Handle capture
                if (capturedPiece) {
                    this.handleCapture(capturedPiece);
                }
                
                // Move piece
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = null;
                piece.hasMoved = true;
                
                // Revolutionary promotion for pawns
                if (piece.type === 'pawn') {
                    const promotionRow = piece.color === 'white' ? 2 : 5; // Rank 6 instead of 8
                    if (toRow === promotionRow) {
                        this.promotePawn(toRow, toCol, piece.color);
                    }
                }
                
                // Check for revolutionary effects
                this.checkRevolutionaryEffects(toRow, toCol, piece);
                
                this.showNotification(`${piece.color} ${piece.type} moves to ${String.fromCharCode(97 + toCol)}${8 - toRow}`);
            }
            
            handleCapture(capturedPiece) {
                // Add to revolution meter
                const points = this.getPieceValue(capturedPiece.type);
                this.revolutionMeter[this.currentPlayer] += points;
                
                this.showNotification(`${capturedPiece.color} ${capturedPiece.type} captured! +${points} revolution points`);
            }
            
            getPieceValue(pieceType) {
                const values = {
                    'pawn': 5, 'knight': 10, 'bishop': 10,
                    'rook': 15, 'queen': 25, 'king': 50
                };
                return values[pieceType] || 0;
            }
            
            promotePawn(row, col, color) {
                // In revolutionary chess, pawns become queens by default (power to the people!)
                this.board[row][col] = { type: 'queen', color: color, hasMoved: true };
                this.showNotification(`Revolutionary promotion! ${color} pawn becomes a queen!`);
            }
            
            checkRevolutionaryEffects(row, col, piece) {
                // Check if piece entered revolution zone
                const inRevolutionZone = this.revolutionZones.some(zone => 
                    zone.row === row && zone.col === col
                );
                
                if (inRevolutionZone) {
                    this.revolutionMeter[piece.color] += 3;
                    this.showNotification(`${piece.color} ${piece.type} joins the revolution! +3 points`);
                }
            }
            
            useAbility(abilityType) {
                const cost = this.getAbilityCost(abilityType);
                if (this.revolutionMeter[this.currentPlayer] < cost) return;
                
                this.revolutionMeter[this.currentPlayer] -= cost;
                
                switch (abilityType) {
                    case 'uprising':
                        this.peasantUprising();
                        break;
                    case 'overthrow':
                        this.overthrowKing();
                        break;
                    case 'barricade':
                        this.buildBarricades();
                        break;
                }
                
                this.updateDisplay();
            }
            
            getAbilityCost(abilityType) {
                const costs = { 'uprising': 15, 'overthrow': 25, 'barricade': 13 };
                return costs[abilityType] || 0;
            }
            
            peasantUprising() {
                // Promote all friendly pawns in revolution zones
                let promoted = 0;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.type === 'pawn' && piece.color === this.currentPlayer) {
                            const inRevolutionZone = this.revolutionZones.some(zone => 
                                zone.row === row && zone.col === col
                            );
                            if (inRevolutionZone) {
                                this.board[row][col] = { type: 'queen', color: piece.color, hasMoved: true };
                                promoted++;
                            }
                        }
                    }
                }
                
                this.showNotification(`Peasant Uprising! ${promoted} pawns promoted to queens!`);
            }
            
            overthrowKing() {
                // Find enemy king and reduce its power (can only move 1 square for 5 turns)
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.type === 'king' && piece.color !== this.currentPlayer) {
                            piece.overthrown = 5; // Turns remaining
                            this.showNotification(`${piece.color} king has been overthrown! Weakened for 5 turns!`);
                            return;
                        }
                    }
                }
            }
            
            buildBarricades() {
                // Create temporary barriers that block movement for 3 turns
                const centerSquares = [
                    {row: 2, col: 3}, {row: 2, col: 4},
                    {row: 5, col: 3}, {row: 5, col: 4}
                ];
                
                centerSquares.forEach(square => {
                    if (!this.board[square.row][square.col]) {
                        this.barricades.push({
                            row: square.row,
                            col: square.col,
                            turnsLeft: 3,
                            owner: this.currentPlayer
                        });
                    }
                });
                
                this.showNotification('Barricades built! Blocking enemy movement for 3 turns!');
            }
            
            switchTurn() {
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                if (this.currentPlayer === 'white') {
                    this.moveCount++;
                }
                
                // Reduce barricade timers
                this.barricades = this.barricades.filter(barricade => {
                    barricade.turnsLeft--;
                    return barricade.turnsLeft > 0;
                });
                
                // Reduce king overthrow timers
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.overthrown) {
                            piece.overthrown--;
                            if (piece.overthrown <= 0) {
                                delete piece.overthrown;
                            }
                        }
                    }
                }
            }
            
            updateDisplay() {
                // Update board
                const squares = document.querySelectorAll('.chess-square');
                squares.forEach(square => {
                    const row = parseInt(square.dataset.row);
                    const col = parseInt(square.dataset.col);
                    const piece = this.board[row][col];
                    
                    // Clear previous classes
                    square.classList.remove('selected', 'possible-move');
                    
                    // Update piece display
                    if (piece) {
                        const pieceHtml = this.pieceSymbols[piece.color][piece.type];
                        square.innerHTML = `<div class="chess-piece ${this.isInRevolutionZone(row, col) ? 'revolutionary' : ''}">${pieceHtml}</div>`;
                    } else {
                        square.innerHTML = '';
                    }
                    
                    // Show barricades
                    const hasBarricade = this.barricades.some(b => b.row === row && b.col === col);
                    if (hasBarricade) {
                        square.innerHTML = '<div class="chess-piece">ðŸš§</div>';
                    }
                    
                    // Highlight selected square
                    if (this.selectedSquare && this.selectedSquare.row === row && this.selectedSquare.col === col) {
                        square.classList.add('selected');
                    }
                    
                    // Show possible moves
                    if (this.selectedSquare && this.isValidMove(this.selectedSquare.row, this.selectedSquare.col, row, col)) {
                        square.classList.add('possible-move');
                    }
                });
                
                // Update status
                document.getElementById('current-turn').textContent = this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1);
                document.getElementById('move-count').textContent = this.moveCount;
                
                // Show easter egg status
                const easterEggStatus = document.getElementById('easter-egg-status');
                if (this.easterEggActive) {
                    easterEggStatus.style.display = 'block';
                } else {
                    easterEggStatus.style.display = 'none';
                }
                
                // Update revolution meter
                const meterElement = document.getElementById('revolution-meter');
                const meterPercent = Math.min(100, (this.revolutionMeter[this.currentPlayer] / 100) * 100);
                meterElement.style.width = meterPercent + '%';
                
                // Update ability buttons
                this.updateAbilityButtons();
            }
            
            updateAbilityButtons() {
                const currentPoints = this.revolutionMeter[this.currentPlayer];
                
                document.getElementById('uprising-btn').disabled = currentPoints < 15;
                document.getElementById('overthrow-btn').disabled = currentPoints < 25;
                document.getElementById('barricade-btn').disabled = currentPoints < 13;
            }
            
            isInRevolutionZone(row, col) {
                return this.revolutionZones.some(zone => zone.row === row && zone.col === col);
            }
            
            showNotification(message) {
                const notification = document.getElementById('notification');
                const content = document.getElementById('notification-content');
                
                // Handle multi-line messages
                content.innerHTML = message.replace(/\n/g, '<br>');
                notification.classList.add('show');
                
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 5000); // Longer display time for easter egg messages
            }
            
            newGame() {
                this.board = this.initializeBoard();
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.moveCount = 1;
                this.gameOver = false;
                this.barricades = [];
                
                // Check for easter egg activation
                if (this.surrenderCount >= 10 && !this.easterEggActive) {
                    this.revolutionMeter = { white: 20000, black: 20000 };
                    this.easterEggActive = true;
                    this.showNotification('ðŸŽ‰ ULTIMATE REVOLUTION ACTIVATED! ðŸŽ‰\n20,000 revolution points granted!\nThe people remember your sacrifices!');
                    
                    // Reset counter after activation
                    this.surrenderCount = 0;
                    localStorage.setItem('revolutionarySurrenders', '0');
                } else {
                    this.revolutionMeter = { white: 0, black: 0 };
                    this.easterEggActive = false;
                }
                
                this.updateDisplay();
                this.showNotification('New revolution begins! Viva la revoluciÃ³n!');
            }
            
            surrender() {
                this.gameOver = true;
                const winner = this.currentPlayer === 'white' ? 'Black' : 'White';
                
                // Track surrender count for easter egg (hidden)
                this.surrenderCount++;
                localStorage.setItem('revolutionarySurrenders', this.surrenderCount.toString());
                
                // Show normal surrender message
                let message = `${this.currentPlayer} surrenders! ${winner} wins the revolution!`;
                
                // Only show special message on exactly the 10th surrender
                if (this.surrenderCount === 10) {
                    message += '\n\nðŸŽŠ YOU HAVE UNLOCKED THE ULTIMATE REVOLUTION! ðŸŽŠ\nStart a new game to receive 20,000 revolution points!\nThe people remember your sacrifices!';
                }
                
                this.showNotification(message);
            }
        }
        
        // Initialize the game
        document.addEventListener('DOMContentLoaded', () => {
            new RevolutionaryChess();
        });
    </script>
</body>
</html>
