<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Interactive Chess Game + Simple AI</title>
<link rel="stylesheet" href="styles.css" />
<script src="https://cdn.tailwindcss.com"></script>
<style>
.chess-board { width: 100%; max-width: 500px; aspect-ratio: 1/1; margin: 0 auto; }
.square { position: relative; width: 12.5%; height: 12.5%; float: left; display: flex; justify-content: center; align-items: center; cursor: pointer; }
.light { background-color: #f0d9b5; }
.dark { background-color: #b58863; }
.highlight { box-shadow: inset 0 0 10px 5px rgba(255,255,0,.5); }
.possible-move { position: absolute; width: 30%; height: 30%; border-radius: 50%; background-color: rgba(0,0,0,.3); }
.piece { width: 80%; height: 80%; background-size: contain; background-repeat: no-repeat; background-position: center; z-index: 1; pointer-events: none; }
.piece.dragging { position: absolute; transform: scale(1.2); z-index: 10; pointer-events: none; }
.king-in-check .piece[data-piece="king"] { box-shadow: 0 0 15px 5px rgba(255,0,0,.7); border-radius: 50%; }
.notation { position: absolute; font-size: 10px; pointer-events: none; }
.rank { left: 2px; top: 2px; }
.file { right: 2px; bottom: 2px; }
@media (max-width: 500px) { .piece { width: 90%; height: 90%; } }
</style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center justify-center p-4">
<div class="max-w-5xl w-full">
  <div class="flex items-center justify-center mb-6">
    <svg id="site-logo" width="48" height="48" viewBox="0 0 48 48" class="mr-4 transition-colors duration-100" xmlns="http://www.w3.org/2000/svg">
      <circle cx="24" cy="24" r="20" fill="#ef4444"/>
      <text x="24" y="30" text-anchor="middle" font-size="18" fill="#fff" font-family="Arial" font-weight="bold">C</text>
    </svg>
    <h1 class="text-3xl md:text-6xl font-bold text-center text-red-500">COMMUNIST CHESS (with AI)</h1>
  </div>

  <div class="flex flex-col md:flex-row items-center justify-center gap-6 md:gap-12">
    <div class="chess-board relative bg-gray-800 shadow-2xl rounded-lg overflow-hidden"></div>

    <div class="w-full md:w-96 mt-4 md:mt-0">
      <div class="bg-gray-800 rounded-lg p-6 shadow-lg min-h-[460px]">
        <div class="flex justify-between items-center mb-4">
          <h2 class="text-xl font-bold">INFO</h2>
          <button id="turn-indicator" class="w-6 h-6 rounded-full border-2 border-white cursor-pointer hover:opacity-80 transition-opacity" title="Click to switch sides"></button>
        </div>

        <div class="mb-4 grid grid-cols-2 gap-3">
          <div>
            <p class="text-sm font-semibold">Turn: <span id="current-turn">White</span></p>
            <p class="text-sm font-semibold">Status: <span id="game-status">Playing</span></p>
          </div>
          <div class="space-y-2">
            <label class="flex items-center gap-2 text-sm">
              <input id="vs-computer" type="checkbox" class="accent-blue-500">
              Play vs Computer
            </label>
            <label class="flex items-center gap-2 text-sm">
              Computer side:
              <select id="computer-side" class="bg-gray-700 border border-gray-600 rounded px-2 py-1 text-sm">
                <option value="black">Black</option>
                <option value="white">White</option>
              </select>
            </label>
          </div>
        </div>

        <div class="mb-4">
          <p class="text-sm font-semibold mb-1">Captured Pieces:</p>
          <div id="captured-pieces" class="flex flex-wrap gap-1 min-h-8"></div>
        </div>

        <div class="flex flex-col gap-2">
          <button id="new-game" class="bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded-lg transition">New Game</button>
          <button id="undo-move" class="bg-gray-600 hover:bg-gray-700 text-white py-2 px-4 rounded-lg transition">Undo Move</button>
          <button id="force-ai" class="bg-purple-600 hover:bg-purple-700 text-white py-2 px-4 rounded-lg transition">Make Computer Move</button>
        </div>

        <div class="mt-4">
          <p class="text-xs text-gray-400">Click a piece to select it, then click a highlighted square to move.</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Promotion Modal -->
  <div id="promotion-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
    <div class="bg-gray-800 p-6 rounded-lg shadow-xl">
      <h3 class="text-xl font-bold mb-4 text-center">Promote Pawn</h3>
      <div class="grid grid-cols-4 gap-2">
        <div class="promotion-option bg-gray-700 hover:bg-gray-600 p-2 rounded cursor-pointer" data-piece="queen">
          <div class="piece w-full h-12"></div>
          <p class="text-center mt-1 text-sm">Queen</p>
        </div>
        <div class="promotion-option bg-gray-700 hover:bg-gray-600 p-2 rounded cursor-pointer" data-piece="rook">
          <div class="piece w-full h-12"></div>
          <p class="text-center mt-1 text-sm">Rook</p>
        </div>
        <div class="promotion-option bg-gray-700 hover:bg-gray-600 p-2 rounded cursor-pointer" data-piece="bishop">
          <div class="piece w-full h-12"></div>
          <p class="text-center mt-1 text-sm">Bishop</p>
        </div>
        <div class="promotion-option bg-gray-700 hover:bg-gray-600 p-2 rounded cursor-pointer" data-piece="knight">
          <div class="piece w-full h-12"></div>
          <p class="text-center mt-1 text-sm">Knight</p>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // ---- SIMPLE AI (one-ply with capture preference) ----
  const AI = {
    pieceValues: { pawn: 100, knight: 320, bishop: 330, rook: 500, queen: 900, king: 20000 },

    chooseMove(game, color) {
      const moves = [];
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const p = game.board[r][c];
          if (p && p.color === color) {
            const legal = game.calculatePossibleMoves(r, c);
            legal.forEach(([tr, tc]) => {
              const moveObj = { from: {r, c}, to: {r: tr, c: tc}, piece: p };
              moveObj.score = this.evaluateMove(game, moveObj, color);
              moves.push(moveObj);
            });
          }
        }
      }
      if (moves.length === 0) return null;
      moves.sort((a,b) => b.score - a.score);
      const top = moves[0].score;
      const near = moves.filter(m => m.score >= top - 10);
      return near[Math.floor(Math.random()*near.length)];
    },

    evaluateMove(game, move, color) {
      const { from, to } = move;
      const opp = color === 'white' ? 'black' : 'white';
      let score = 0;

      const target = game.board[to.r][to.c];
      if (target) {
        score += (this.pieceValues[target.type] || 0) - Math.floor((this.pieceValues[move.piece.type] || 0) * 0.1);
      }

      if ((color === 'white' && from.r >= 6) || (color === 'black' && from.r <= 1)) score += 3;

      const ofp = game.board[from.r][from.c];
      const otp = game.board[to.r][to.c];
      game.board[to.r][to.c] = ofp;
      game.board[from.r][from.c] = null;
      const hanging = this.squareAttackedBy(game, to.r, to.c, opp);
      game.board[from.r][from.c] = ofp;
      game.board[to.r][to.c] = otp;

      if (hanging) score -= target ? 70 : 120;
      if (this.givesCheck(game, move, color)) score += 25;
      score += Math.floor(Math.random()*5);
      return score;
    },

    squareAttackedBy(game, row, col, attackerColor) {
      for (let r=0;r<8;r++){
        for (let c=0;c<8;c++){
          const p = game.board[r][c];
          if (p && p.color === attackerColor) {
            const moves = game.calculateRawMoves(r,c);
            if (moves.some(([tr,tc]) => tr===row && tc===col)) return true;
          }
        }
      }
      return false;
    },

    givesCheck(game, move, color) {
      const opp = color === 'white' ? 'black' : 'white';
      const { from, to } = move;
      const ofp = game.board[from.r][from.c];
      const otp = game.board[to.r][to.c];
      game.board[to.r][to.c] = ofp;
      game.board[from.r][from.c] = null;
      const inCheck = game.isKingInCheck(opp);
      game.board[from.r][from.c] = ofp;
      game.board[to.r][to.c] = otp;
      return inCheck;
    }
  };

  // ----- Game Object -----
  const game = {
    board: Array(8).fill().map(() => Array(8).fill(null)),
    turn: 'white',
    selectedSquare: null,
    possibleMoves: [],
    moveHistory: [],
    capturedPieces: { white: [], black: [] },
    check: false,
    gameOver: false,
    lastMove: null,
    promotingPawn: null,
    vsComputer: false,
    computerSide: 'black',

    init() {
      this.setupBoard();
      this.renderBoard();
      this.setupEventListeners();
      this.updateGameInfo();
    },

    setupBoard() {
      for (let col = 0; col < 8; col++) {
        this.board[1][col] = { type: 'pawn', color: 'black', hasMoved: false };
        this.board[6][col] = { type: 'pawn', color: 'white', hasMoved: false };
      }
      this.board[0][0] = { type: 'rook', color: 'black', hasMoved: false };
      this.board[0][7] = { type: 'rook', color: 'black', hasMoved: false };
      this.board[7][0] = { type: 'rook', color: 'white', hasMoved: false };
      this.board[7][7] = { type: 'rook', color: 'white', hasMoved: false };

      this.board[0][1] = { type: 'knight', color: 'black' };
      this.board[0][6] = { type: 'knight', color: 'black' };
      this.board[7][1] = { type: 'knight', color: 'white' };
      this.board[7][6] = { type: 'knight', color: 'white' };

      this.board[0][2] = { type: 'bishop', color: 'black' };
      this.board[0][5] = { type: 'bishop', color: 'black' };
      this.board[7][2] = { type: 'bishop', color: 'white' };
      this.board[7][5] = { type: 'bishop', color: 'white' };

      this.board[0][3] = { type: 'queen', color: 'black' };
      this.board[7][3] = { type: 'queen', color: 'white' };

      this.board[0][4] = { type: 'king', color: 'black', hasMoved: false };
      this.board[7][4] = { type: 'king', color: 'white', hasMoved: false };
    },

    renderBoard() {
      const boardElement = document.querySelector('.chess-board');
      boardElement.innerHTML = '';
      for (let row=0; row<8; row++) {
        for (let col=0; col<8; col++) {
          const square = document.createElement('div');
          square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
          square.dataset.row = row;
          square.dataset.col = col;

          if (col === 0) {
            const rank = document.createElement('div');
            rank.className = 'notation rank';
            rank.textContent = 8 - row;
            square.appendChild(rank);
          }
          if (row === 7) {
            const file = document.createElement('div');
            file.className = 'notation file';
            file.textContent = String.fromCharCode(97 + col);
            square.appendChild(file);
          }

          const piece = this.board[row][col];
          if (piece) {
            const pieceElement = document.createElement('div');
            pieceElement.className = 'piece';
            pieceElement.dataset.piece = piece.type;
            pieceElement.dataset.color = piece.color;
            const svg = this.getPieceSVG(piece.type, piece.color);
            pieceElement.style.backgroundImage = `url('data:image/svg+xml;utf8,${encodeURIComponent(svg)}')`;
            square.appendChild(pieceElement);
          }
          boardElement.appendChild(square);
        }
      }
      document.querySelectorAll('.promotion-option .piece').forEach((el, idx) => {
        const types = ['queen','rook','bishop','knight'];
        const svg = this.getPieceSVG(types[idx], this.turn);
        el.style.backgroundImage = `url('data:image/svg+xml;utf8,${encodeURIComponent(svg)}')`;
      });
    },

    getPieceSVG(type, color) {
      const pieceColor = color === 'white' ? '#fff' : '#000';
      const oppositeColor = color === 'white' ? '#000' : '#fff';
      switch(type) {
        case 'pawn':
          return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
            <path d="M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z"
            stroke="${oppositeColor}" fill="${pieceColor}" stroke-width="1.5" stroke-linecap="round"/></svg>`;
        case 'rook':
          return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
            <g fill="${pieceColor}" stroke="${oppositeColor}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 39h27v-3H9v3zM12 36v-4h21v4H12zM11 14V9h4v2h5V9h5v2h5V9h4v5"/>
              <path d="M34 14l-3 3H14l-3-3"/>
              <path d="M31 17v12.5H14V17"/>
              <path d="M31 29.5l1.5 2.5h-20l1.5-2.5z"/>
              <path d="M11 14h23"/>
            </g></svg>`;
        case 'knight':
          return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
            <g fill="${pieceColor}" stroke="${oppositeColor}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21"/>
              <path d="M24 18c.38 2.91-5.55 7.37-8 9-3 2-2.82 4.34-5 4-1.042-.94 1.41-3.04 0-3-1 0 .19 1.23-1 2-1 0-4.003 1-4-1 0-2 6-12 6-12s1.89-1.9 2-3.5c-.73-.994-.5-2-.5-3 1-1 3 2.5 3 2.5h2s.78-1.992 2.5-3c1 0 1 3 1 3"/>
              <circle cx="9.5" cy="25.5" r=".5" fill="${oppositeColor}"/>
              <circle cx="14.933" cy="15.75" r="1" fill="${oppositeColor}"/>
            </g></svg>`;
        case 'bishop':
          return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
            <g fill="${pieceColor}" stroke="${oppositeColor}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .5-3.39-.97-10.11.46-13.5-1-3.39 1.46-10.11.03-13.5 1-1.354.49-2.323.47-3-.5 1.354-1.94 3-2 3-2z"/>
              <path d="M15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z"/>
              <circle cx="22.5" cy="8.5" r="2.5" stroke="${oppositeColor}"/>
            </g></svg>`;
        case 'queen':
          return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
            <g fill="${pieceColor}" stroke="${oppositeColor}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 26c8.5-1.5 21-1.5 27 0l2.5-12.5L31 25l-.3-14.1-5.2 13.6-3-14.5-3 14.5-5.2-13.6L14 25 6.5 13.5 9 26z"/>
              <path d="M9 26c0 2 1.5 2 2.5 4 1 1.5 1 1 .5 3.5-1.5 1-1 2.5-1 2.5-1.5 1.5 0 2.5 0 2.5 6.5 1 16.5 1 23 0 0 0 1.5-1 0-2.5 0 0 .5-1.5-1-2.5-.5-2.5-.5-2 .5-3.5 1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z"/>
              <path d="M11.5 30c3.5-1 18.5-1 22 0m-21.5 1.5c2-1 15-1 17 0" fill="none"/>
            </g></svg>`;
        case 'king':
          return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
            <g fill="${pieceColor}" stroke="${oppositeColor}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M22.5 11.63V6M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5"/>
              <path d="M12.5 37c5.5 3.5 14.5 3.5 20 0v-7s9-4.5 6-10.5c-4-6.5-13.5-3.5-16 4V27v-3.5c-2.5-7.5-12-10.5-16-4-3 6 6 10.5 6 10.5v7"/>
              <path d="M20 8h5"/>
              <circle cx="22.5" cy="6.5" r="2" stroke="${oppositeColor}"/>
            </g></svg>`;
        default: return '';
      }
    },

    setupEventListeners() {
      const board = document.querySelector('.chess-board');

      document.getElementById('turn-indicator').addEventListener('click', () => {
        this.switchTurns();
        this.clearSelection();
        this.maybeAIMove();
      });

      document.getElementById('vs-computer').addEventListener('change', (e) => {
        this.vsComputer = e.target.checked;
        this.maybeAIMove(true);
      });

      document.getElementById('computer-side').addEventListener('change', (e) => {
        this.computerSide = e.target.value;
        this.maybeAIMove(true);
      });

      document.getElementById('force-ai').addEventListener('click', () => {
        this.maybeAIMove(true);
      });

      board.addEventListener('click', (e) => {
        if (this.gameOver) return;
        const square = e.target.closest('.square');
        if (!square) return;
        const row = parseInt(square.dataset.row);
        const col = parseInt(square.dataset.col);

        if (this.vsComputer && this.turn === this.computerSide) return;

        if (this.selectedSquare === null) {
          const piece = this.board[row][col];
          if (piece && piece.color === this.turn) {
            this.selectSquare(row, col);
          }
        } else {
          const [fromRow, fromCol] = this.selectedSquare;
          if (this.isValidMove(fromRow, fromCol, row, col)) {
            this.movePiece(fromRow, fromCol, row, col);
            this.clearSelection();
            this.maybeAIMove();
          } else {
            const piece = this.board[row][col];
            if (piece && piece.color === this.turn) {
              this.selectSquare(row, col);
            } else {
              this.clearSelection();
            }
          }
        }
      });

      document.getElementById('new-game').addEventListener('click', () => {
        this.resetGame();
        this.maybeAIMove(true);
      });

      document.getElementById('undo-move').addEventListener('click', () => {
        this.undoMove();
      });

      document.querySelectorAll('.promotion-option').forEach(option => {
        option.addEventListener('click', (e) => {
          const pieceType = e.currentTarget.dataset.piece;
          this.completePromotion(pieceType);
        });
      });
    },

    selectSquare(row, col) {
      this.clearSelection();
      this.selectedSquare = [row, col];
      const square = this.getSquareElement(row, col);
      square.classList.add('highlight');
      this.possibleMoves = this.calculatePossibleMoves(row, col);
      this.showPossibleMoves();
    },

    clearSelection() {
      if (this.selectedSquare) {
        const [row, col] = this.selectedSquare;
        const square = this.getSquareElement(row, col);
        square.classList.remove('highlight');
      }
      this.hidePossibleMoves();
      this.selectedSquare = null;
      this.possibleMoves = [];
    },

    showPossibleMoves() {
      this.possibleMoves.forEach(([row, col]) => {
        const square = this.getSquareElement(row, col);
        const marker = document.createElement('div');
        marker.className = 'possible-move';
        square.appendChild(marker);
      });
    },

    hidePossibleMoves() { document.querySelectorAll('.possible-move').forEach(m => m.remove()); },

    calculatePossibleMoves(row, col) {
      const piece = this.board[row][col];
      if (!piece) return [];
      const moves = [];
      const color = piece.color;
      const opponentColor = color === 'white' ? 'black' : 'white';

      const isInBounds = (r,c)=> r>=0 && r<8 && c>=0 && c<8;
      const addDirectionalMoves = (dr, dc) => {
        let r=row+dr, c=col+dc;
        while (isInBounds(r,c)) {
          if (!this.board[r][c]) moves.push([r,c]);
          else { if (this.board[r][c].color === opponentColor) moves.push([r,c]); break; }
          r+=dr; c+=dc;
        }
      };

      switch (piece.type) {
        case 'pawn': {
          const dir = color === 'white' ? -1 : 1;
          if (isInBounds(row+dir,col) && !this.board[row+dir][col]) {
            moves.push([row+dir, col]);
            if (!piece.hasMoved && isInBounds(row+2*dir,col) && !this.board[row+2*dir][col] && !this.board[row+dir][col]) {
              moves.push([row+2*dir, col]);
            }
          }
          for (const dc of [-1,1]) {
            const r=row+dir, c=col+dc;
            if (!isInBounds(r,c)) continue;
            if (this.board[r][c] && this.board[r][c].color===opponentColor) moves.push([r,c]);
            if (!this.board[r][c] && this.lastMove &&
                this.lastMove.piece.type==='pawn' && this.lastMove.piece.color===opponentColor &&
                Math.abs(this.lastMove.from.row - this.lastMove.to.row)===2 &&
                this.lastMove.to.row===row && this.lastMove.to.col===c) {
              moves.push([r,c]);
            }
          }
          break;
        }
        case 'rook': [[1,0],[-1,0],[0,1],[0,-1]].forEach(d=>addDirectionalMoves(...d)); break;
        case 'knight':
          [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(([dr,dc])=>{
            const r=row+dr,c=col+dc;
            if (isInBounds(r,c) && (!this.board[r][c] || this.board[r][c].color===opponentColor)) moves.push([r,c]);
          }); break;
        case 'bishop': [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(d=>addDirectionalMoves(...d)); break;
        case 'queen': [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(d=>addDirectionalMoves(...d)); break;
        case 'king':
          for (let r=row-1; r<=row+1; r++) for (let c=col-1; c<=col+1; c++) {
            if ((r!==row || c!==col) && isInBounds(r,c) && (!this.board[r][c] || this.board[r][c].color===opponentColor)) moves.push([r,c]);
          }
          break;
      }

      return moves.filter(([tr,tc]) => {
        const original = this.board[tr][tc];
        this.board[tr][tc] = this.board[row][col];
        this.board[row][col] = null;
        const inCheck = this.isKingInCheck(color);
        this.board[row][col] = this.board[tr][tc];
        this.board[tr][tc] = original;
        return !inCheck;
      });
    },

    isValidMove(fr,fc,tr,tc) { return this.possibleMoves.some(([r,c]) => r===tr && c===tc); },

    movePiece(fr,fc,tr,tc) {
      const piece = this.board[fr][fc];
      const isPawnPromotion = piece.type==='pawn' && ((piece.color==='white' && tr===0) || (piece.color==='black' && tr===7));
      const move = {
        from:{row:fr,col:fc},
        to:{row:tr,col:tc},
        piece:{...piece},
        captured: this.board[tr][tc] ? {...this.board[tr][tc]} :
                  (piece.type==='pawn' && fc!==tc && !this.board[tr][tc]) ? {...this.board[fr][tc]} : null,
        promotion: isPawnPromotion
      };

      if (this.board[tr][tc]) {
        const capturedPiece = this.board[tr][tc];
        this.capturedPieces[this.turn].push(capturedPiece);
        this.updateCapturedPiecesDisplay();
      } else if (piece.type==='pawn' && fc!==tc && !this.board[tr][tc]) {
        const capturedPawnRow = fr;
        const capturedPawnCol = tc;
        const capturedPiece = this.board[capturedPawnRow][capturedPawnCol];
        this.capturedPieces[this.turn].push(capturedPiece);
        this.board[capturedPawnRow][capturedPawnCol] = null;
        this.updateCapturedPiecesDisplay();
      }

      this.board[tr][tc] = piece;
      this.board[fr][fc] = null;

      if (piece.type==='pawn' || piece.type==='rook' || piece.type==='king') piece.hasMoved = true;

      if (isPawnPromotion) {
        this.promotingPawn = { row: tr, col: tc };
        this.showPromotionModal();
      } else {
        this.switchTurns();
        this.lastMove = move;
        this.moveHistory.push(move);
        this.checkGameStatus();
      }
      this.renderBoard();
    },

    showPromotionModal() { document.getElementById('promotion-modal').classList.remove('hidden'); },
    hidePromotionModal() { document.getElementById('promotion-modal').classList.add('hidden'); },

    completePromotion(pieceType) {
      if (!this.promotingPawn) return;
      const { row, col } = this.promotingPawn;
      this.board[row][col].type = pieceType;
      this.promotingPawn = null;
      this.hidePromotionModal();
      this.switchTurns();
      this.checkGameStatus();
      this.renderBoard();
      this.maybeAIMove();
    },

    switchTurns() {
      this.turn = this.turn === 'white' ? 'black' : 'white';
      this.updateGameInfo();
      document.getElementById('turn-indicator').style.backgroundColor = this.turn === 'white' ? 'white' : 'black';
    },

    isKingInCheck(color) {
      let kingRow, kingCol;
      for (let r=0;r<8;r++){
        for (let c=0;c<8;c++){
          const p=this.board[r][c];
          if (p && p.type==='king' && p.color===color){ kingRow=r; kingCol=c; break; }
        }
        if (kingRow!==undefined) break;
      }
      const opp = color==='white' ? 'black' : 'white';
      for (let r=0;r<8;r++){
        for (let c=0;c<8;c++){
          const p=this.board[r][c];
          if (p && p.color===opp){
            const moves=this.calculateRawMoves(r,c);
            if (moves.some(([tr,tc])=>tr===kingRow && tc===kingCol)) return true;
          }
        }
      }
      return false;
    },

    calculateRawMoves(row,col){
      const piece = this.board[row][col];
      if (!piece) return [];
      const color = piece.color;
      const opp = color==='white' ? 'black' : 'white';
      const isInBounds=(r,c)=> r>=0 && r<8 && c>=0 && c<8;
      const moves=[];
      const addDir=(dr,dc)=>{ let r=row+dr,c=col+dc; while(isInBounds(r,c)){ if(!this.board[r][c]) moves.push([r,c]); else { if(this.board[r][c].color===opp) moves.push([r,c]); break; } r+=dr; c+=dc; } };

      switch(piece.type){
        case 'pawn': {
          const dir=color==='white'?-1:1;
          if (isInBounds(row+dir,col) && !this.board[row+dir][col]){
            moves.push([row+dir,col]);
            if(!piece.hasMoved && isInBounds(row+2*dir,col) && !this.board[row+2*dir][col]) moves.push([row+2*dir,col]);
          }
          for (const dc of [-1,1]){
            const r=row+dir, c=col+dc;
            if (isInBounds(r,c) && this.board[r][c] && this.board[r][c].color===opp) moves.push([r,c]);
          }
          break;
        }
        case 'rook': [[1,0],[-1,0],[0,1],[0,-1]].forEach(d=>addDir(...d)); break;
        case 'knight': [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(([dr,dc])=>{
          const r=row+dr,c=col+dc; if(isInBounds(r,c) && (!this.board[r][c] || this.board[r][c].color===opp)) moves.push([r,c]);
        }); break;
        case 'bishop': [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(d=>addDir(...d)); break;
        case 'queen': [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(d=>addDir(...d)); break;
        case 'king':
          for (let r=row-1;r<=row+1;r++) for (let c=col-1;c<=col+1;c++){
            if ((r!==row || c!==col) && isInBounds(r,c) && (!this.board[r][c] || this.board[r][c].color===opp)) moves.push([r,c]);
          }
          break;
      }
      return moves;
    },

    checkGameStatus() {
      const inCheck = this.isKingInCheck(this.turn);
      this.highlightKingInCheck(this.turn, inCheck);

      let hasLegal=false;
      for (let r=0;r<8;r++){
        for (let c=0;c<8;c++){
          const p=this.board[r][c];
          if (p && p.color===this.turn){
            const mv=this.calculatePossibleMoves(r,c);
            if (mv.length>0){ hasLegal=true; break; }
          }
        }
        if (hasLegal) break;
      }
      if (!hasLegal){
        this.gameOver = true;
        if (inCheck) document.getElementById('game-status').textContent = `Checkmate - ${this.turn==='white'?'Black':'White'} wins!`;
        else document.getElementById('game-status').textContent = 'Stalemate - Draw!';
      } else if (inCheck){
        this.check = true;
        document.getElementById('game-status').textContent = 'Check!';
      } else {
        this.check = false;
        if (!this.gameOver) document.getElementById('game-status').textContent = 'Playing';
      }
    },

    updateGameInfo() {
      document.getElementById('current-turn').textContent = this.turn === 'white' ? 'White' : 'Black';
      document.getElementById('turn-indicator').style.backgroundColor = this.turn === 'white' ? 'white' : 'black';
      if (this.check) document.getElementById('game-status').textContent = 'Check!';
      else if (!this.gameOver) document.getElementById('game-status').textContent = 'Playing';
    },

    updateCapturedPiecesDisplay() {
      const container = document.getElementById('captured-pieces');
      container.innerHTML = '';
      for (const color of ['white','black']) {
        this.capturedPieces[color].forEach(piece=>{
          const el=document.createElement('div');
          el.className='piece w-4 h-4 md:w-6 md:h-6';
          const svg=this.getPieceSVG(piece.type, color==='white'?'black':'white');
          el.style.backgroundImage=`url('data:image/svg+xml;utf8,${encodeURIComponent(svg)}')`;
          container.appendChild(el);
        });
      }
    },

    undoMove() {
      if (this.moveHistory.length===0) return;
      const lastMove = this.moveHistory.pop();
      this.board[lastMove.from.row][lastMove.from.col] = lastMove.piece;
      if (lastMove.captured){
        this.board[lastMove.to.row][lastMove.to.col] = lastMove.captured;
        const idx = this.capturedPieces[this.turn].findIndex(p=>p.type===lastMove.captured.type && p.color===lastMove.captured.color);
        if (idx!==-1) this.capturedPieces[this.turn].splice(idx,1);
      } else {
        this.board[lastMove.to.row][lastMove.to.col] = null;
      }
      this.switchTurns();
      this.gameOver=false;
      this.check=false;
      this.updateGameInfo();
      this.updateCapturedPiecesDisplay();
      this.renderBoard();
    },

    resetGame() {
      this.board = Array(8).fill().map(()=>Array(8).fill(null));
      this.setupBoard();
      this.turn = 'white';
      this.selectedSquare = null;
      this.possibleMoves = [];
      this.moveHistory = [];
      this.capturedPieces = { white: [], black: [] };
      this.check=false;
      this.gameOver=false;
      this.promotingPawn=null;
      this.updateGameInfo();
      this.updateCapturedPiecesDisplay();
      this.renderBoard();
      this.hidePromotionModal();
    },

    getSquareElement(r,c){ return document.querySelector(`.square[data-row="${r}"][data-col="${c}"]`); },

    highlightKingInCheck(color, inCheck){
      let kr,kc;
      for (let r=0;r<8;r++){
        for (let c=0;c<8;c++){
          const p=this.board[r][c];
          if (p && p.type==='king' && p.color===color){ kr=r; kc=c; break; }
        }
        if (kr!==undefined) break;
      }
      const sq = this.getSquareElement(kr,kc);
      if (!sq) return;
      if (inCheck) sq.classList.add('king-in-check'); else sq.classList.remove('king-in-check');
    },

    maybeAIMove(force=false){
      if (!this.vsComputer) return;
      if (this.gameOver) return;
      if (this.turn !== this.computerSide) return;
      setTimeout(()=>{
        const move = AI.chooseMove(this, this.turn);
        if (!move) return;
        this.movePiece(move.from.r, move.from.c, move.to.r, move.to.c);
        if (this.promotingPawn && this.turn !== this.computerSide) {
          this.completePromotion('queen');
        }
      }, force ? 150 : 250);
    }
  };

  game.init();
});
</script>
</body>
</html>
