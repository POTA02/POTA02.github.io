<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Interactive Chess Game + Simple AI</title>
<link rel="stylesheet" href="styles.css" />
<script src="https://cdn.tailwindcss.com"></script>
<script src="extended-chess-ai/config.js"></script>
<script src="extended-chess-ai/ExtendedChessAI.js"></script>
<script src="extended-chess-ai/integration.js"></script>
<style>
.chess-board { width: 100%; max-width: 600px; aspect-ratio: 1/1; margin: 0 auto; border: 3px solid #8b4513; box-shadow: 0 0 20px rgba(0,0,0,0.3); }
.square { position: relative; width: 8.333333%; height: 8.333333%; float: left; display: flex; justify-content: center; align-items: center; cursor: pointer; }
.light { background-color: #f0d9b5; }
.dark { background-color: #b58863; }
.border-light { background-color: #d4c4a8; }
.border-dark { background-color: #a0906b; }
.highlight { box-shadow: inset 0 0 10px 5px rgba(255,255,0,.5); }
.possible-move { position: absolute; width: 30%; height: 30%; border-radius: 50%; background-color: rgba(0,0,0,.3); }
.piece { width: 80%; height: 80%; background-size: contain; background-repeat: no-repeat; background-position: center; z-index: 1; pointer-events: none; }
.piece.dragging { position: absolute; transform: scale(1.2); z-index: 10; pointer-events: none; }
.king-in-check .piece[data-piece="king"] { box-shadow: 0 0 15px 5px rgba(255,0,0,.7); border-radius: 50%; }
.notation { position: absolute; font-size: 10px; pointer-events: none; }
.rank { left: 2px; top: 2px; }
.file { right: 2px; bottom: 2px; }
@media (max-width: 500px) { .piece { width: 90%; height: 90%; } }

/* Advanced Hints CSS */
.hint-primary {
  background-color: #10b981 !important;
  box-shadow: 0 0 20px rgba(16, 185, 129, 0.6);
  border: 3px solid #059669;
}

.hint-secondary {
  background-color: #3b82f6 !important;
  box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
  border: 2px solid #2563eb;
}

.prediction-arrow {
  position: absolute;
  pointer-events: none;
  z-index: 10;
  font-size: 30px;
  color: #ef4444;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 0.7; transform: scale(1); }
  50% { opacity: 1; transform: scale(1.1); }
}

.advanced-hints-button {
  background: linear-gradient(45deg, #8b5cf6, #ec4899) !important;
  color: white !important;
  border: none !important;
  box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4) !important;
  animation: glow 2s infinite alternate;
}

@keyframes glow {
  from { box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4); }
  to { box-shadow: 0 6px 25px rgba(139, 92, 246, 0.8); }
}

.bot-move-button {
  background: linear-gradient(45deg, #f59e0b, #ef4444) !important;
  color: white !important;
  border: none !important;
  animation: shimmer 3s infinite;
}

.bot-move-button:disabled {
  background: #6b7280 !important;
  cursor: not-allowed !important;
  animation: none !important;
}

@keyframes shimmer {
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
}

@keyframes slideIn {
  from { transform: translateX(100%); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
}
</style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center justify-center p-4">
            Wenn du das siehst bist du dumm | If you see this then you're dumb
<div id="rules-popup" style="z-index:1000;" class="fixed inset-0 flex items-center justify-center bg-gradient-to-br from-pink-500/80 via-yellow-400/80 to-blue-500/80">
  <div id="rules-popup-inner" class="transition-all duration-300 bg-white rounded-2xl shadow-2xl p-8 max-w-xs w-full border-4 border-pink-400 flex flex-col items-center relative">
    <h2 class="text-3xl font-extrabold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-pink-500 via-yellow-400 to-blue-500 animate-pulse">RULES CHANGED</h2>
    <ul class="text-lg font-semibold text-gray-800 mb-4 space-y-2">
      <li><span class="font-bold text-pink-600">-</span> <span class="text-blue-600">Removed Castling</span></li>
      <li><span class="font-bold text-pink-600">-</span> <span class="text-yellow-600">Removed En passant</span></li>
    </ul>
    <div id="reason-text" class="overflow-hidden transition-all duration-300 h-0 text-center text-purple-700 font-bold text-lg mb-2"></div>
    <div class="flex gap-4 mt-2">
      <button id="merged-close" class="bg-gradient-to-r from-green-400 via-yellow-400 to-blue-500 text-white font-bold px-4 py-2 rounded-lg shadow hover:scale-105 transition-transform">CLOSE</button>
      <button id="rules-reason" class="bg-gradient-to-r from-yellow-400 via-pink-500 to-red-500 text-white font-bold px-4 py-2 rounded-lg shadow hover:scale-105 transition-transform">REASON</button>
    </div>
  </div>
</div>

<!-- BETA ROLLING TEXT POPUP -->
<div id="beta-popup" style="z-index:999; display:none;" class="fixed inset-0 flex items-center justify-center bg-black/60">
  <div class="rounded-2xl shadow-2xl p-8 max-w-md w-full border-4 border-blue-400 flex flex-col items-center relative bg-gradient-to-br from-blue-400/80 via-pink-400/80 to-yellow-300/80">
    <div class="w-full overflow-hidden h-12 flex items-center justify-center mb-2">
      <div id="rolling-text" class="whitespace-nowrap text-2xl md:text-3xl font-extrabold bg-gradient-to-r from-pink-500 via-yellow-400 to-blue-500 bg-clip-text text-transparent animate-rolling">THIS IS A BETA RELEASE</div>
    </div>
    <div class="text-sm text-gray-700 font-semibold text-center mt-2 animate-pulse">some features may not work due to instability.</div>
    <button id="merged-close-beta" class="mt-6 px-6 py-2 rounded-lg font-bold text-lg shadow-lg bg-gradient-to-r from-green-400 via-yellow-400 to-blue-500 text-white border-4 border-blue-400 hover:scale-105 transition-transform">CLOSE</button>
  </div>
</div>

<style>
@keyframes rolling {
  0% { transform: translateX(100%); }
  100% { transform: translateX(-100%); }
}
.animate-rolling {
  animation: rolling 5s linear 1;
}
</style>
<div class="max-w-5xl w-full">
  <div class="flex items-center justify-center mb-6">
    <svg id="site-logo" width="48" height="48" viewBox="0 0 48 48" class="mr-4 transition-colors duration-100" xmlns="http://www.w3.org/2000/svg">
      <circle cx="24" cy="24" r="20" fill="#ef4444"/>
      <text x="24" y="30" text-anchor="middle" font-size="18" fill="#fff" font-family="Arial" font-weight="bold">C</text>
    </svg>
    <h1 class="text-3xl md:text-6xl font-bold text-center text-red-500">COMMUNIST CHESS (with AI)</h1>
  </div>

  <div class="flex flex-col md:flex-row items-center justify-center gap-6 md:gap-12">
    <div class="chess-board relative bg-gray-800 shadow-2xl rounded-lg overflow-hidden"></div>

    <div class="w-full md:w-96 mt-4 md:mt-0">
      <div class="bg-gray-800 rounded-lg p-6 shadow-lg min-h-[460px]">
        <div class="flex justify-between items-center mb-4">
          <h2 class="text-xl font-bold">INFO</h2>
          <button id="turn-indicator" class="w-6 h-6 rounded-full border-2 border-white cursor-pointer hover:opacity-80 transition-opacity" title="Click to switch sides"></button>
        </div>

        <div class="mb-4 grid grid-cols-2 gap-3">
          <div>
            <p class="text-sm font-semibold">Turn: <span id="current-turn">White</span></p>
            <p class="text-sm font-semibold">Status: <span id="game-status">Playing</span></p>
          </div>
          <div class="space-y-2">
            <label class="flex items-center gap-2 text-sm">
              <input id="vs-computer" type="checkbox" class="accent-blue-500">
              Play vs Computer
            </label>
            <label class="flex items-center gap-2 text-sm">
              Computer side:
              <select id="computer-side" class="bg-gray-700 border border-gray-600 rounded px-2 py-1 text-sm">
                <option value="black">Black</option>
                <option value="white">White</option>
              </select>
            </label>
          </div>
        </div>

        <div class="mb-4">
          <p class="text-sm font-semibold mb-1">Captured Pieces:</p>
          <div id="captured-pieces" class="flex flex-wrap gap-1 min-h-8"></div>
        </div>

        <div class="flex flex-col gap-2">
          <button id="new-game" class="bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded-lg transition">New Game</button>
          <button id="advanced-hints-btn" class="advanced-hints-button py-2 px-4 rounded-lg transition font-bold hidden">ADVANCED HINTS</button>
          <button id="undo-move" class="bg-gray-600 hover:bg-gray-700 text-white py-2 px-4 rounded-lg transition">Undo Move</button>
          <button id="force-ai" class="bg-purple-600 hover:bg-purple-700 text-white py-2 px-4 rounded-lg transition">Make Computer Move</button>
          <button id="bot-move-btn" class="bot-move-button py-2 px-4 rounded-lg transition font-bold hidden">MAKE BOT MOVE</button>
          <button id="toggle-voice" class="bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded-lg transition">üé§ Voice: OFF</button>
          <button id="voice-settings" class="bg-indigo-600 hover:bg-indigo-700 text-white py-2 px-4 rounded-lg transition">‚öôÔ∏è Voice Settings</button>
          <button id="goated-btn" class="mt-2 w-full py-2 px-4 rounded-lg font-extrabold text-lg shadow-lg transition-transform hover:scale-105 bg-gradient-to-r from-pink-500 via-yellow-400 to-blue-500 text-white border-4 border-pink-400 animate-pulse">GOATED BUTTON</button>
        </div>

        <div class="mt-4">
          <p class="text-xs text-gray-400">Click a piece to select it, then click a highlighted square to move.</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Promotion Modal -->
  <div id="promotion-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
    <div class="bg-gray-800 p-6 rounded-lg shadow-xl">
      <h3 class="text-xl font-bold mb-4 text-center">Promote Pawn</h3>
      <div class="grid grid-cols-4 gap-2">
        <div class="promotion-option bg-gray-700 hover:bg-gray-600 p-2 rounded cursor-pointer" data-piece="queen">
          <div class="piece w-full h-12"></div>
          <p class="text-center mt-1 text-sm">Queen</p>
        </div>
        <div class="promotion-option bg-gray-700 hover:bg-gray-600 p-2 rounded cursor-pointer" data-piece="rook">
          <div class="piece w-full h-12"></div>
          <p class="text-center mt-1 text-sm">Rook</p>
        </div>
        <div class="promotion-option bg-gray-700 hover:bg-gray-600 p-2 rounded cursor-pointer" data-piece="bishop">
          <div class="piece w-full h-12"></div>
          <p class="text-center mt-1 text-sm">Bishop</p>
        </div>
        <div class="promotion-option bg-gray-700 hover:bg-gray-600 p-2 rounded cursor-pointer" data-piece="knight">
          <div class="piece w-full h-12"></div>
          <p class="text-center mt-1 text-sm">Knight</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Voice Settings Modal -->
  <div id="voice-settings-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
    <div class="bg-gray-800 p-6 rounded-lg shadow-xl max-w-md w-full">
      <h3 class="text-xl font-bold mb-4 text-center">üé§ Voice Assistant Settings</h3>
      
      <div class="space-y-4">
        <!-- Voice Personality -->
        <div>
          <label class="block text-sm font-medium mb-2">Personality</label>
          <select id="voice-personality" class="w-full bg-gray-700 text-white p-2 rounded border border-gray-600">
            <option value="professional">Professional</option>
            <option value="casual">Casual</option>
            <option value="dramatic">Dramatic</option>
            <option value="funny">Funny</option>
          </select>
        </div>

        <!-- Voice Speed -->
        <div>
          <label class="block text-sm font-medium mb-2">Speed: <span id="speed-value">1.0</span>x</label>
          <input type="range" id="voice-speed" min="0.5" max="2.0" step="0.1" value="1.0" 
                 class="w-full bg-gray-700 rounded-lg appearance-none cursor-pointer">
        </div>

        <!-- Voice Pitch -->
        <div>
          <label class="block text-sm font-medium mb-2">Pitch: <span id="pitch-value">1.0</span></label>
          <input type="range" id="voice-pitch" min="0.5" max="2.0" step="0.1" value="1.0" 
                 class="w-full bg-gray-700 rounded-lg appearance-none cursor-pointer">
        </div>

        <!-- Voice Volume -->
        <div>
          <label class="block text-sm font-medium mb-2">Volume: <span id="volume-value">80</span>%</label>
          <input type="range" id="voice-volume" min="0" max="100" step="5" value="80" 
                 class="w-full bg-gray-700 rounded-lg appearance-none cursor-pointer">
        </div>

        <!-- Announcement Categories -->
        <div>
          <label class="block text-sm font-medium mb-2">Announcements</label>
          <div class="space-y-2">
            <label class="flex items-center">
              <input type="checkbox" id="announce-moves" checked class="mr-2">
              <span>Moves</span>
            </label>
            <label class="flex items-center">
              <input type="checkbox" id="announce-ai" checked class="mr-2">
              <span>AI Actions</span>
            </label>
            <label class="flex items-center">
              <input type="checkbox" id="announce-game-events" checked class="mr-2">
              <span>Game Events</span>
            </label>
            <label class="flex items-center">
              <input type="checkbox" id="announce-cheats" checked class="mr-2">
              <span>Cheat Activations</span>
            </label>
          </div>
        </div>

        <!-- Test Voice Button -->
        <button id="test-voice" class="w-full bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded-lg transition">
          Test Voice
        </button>
      </div>

      <div class="flex gap-2 mt-6">
        <button id="voice-settings-close" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white py-2 px-4 rounded-lg transition">
          Close
        </button>
        <button id="voice-settings-save" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded-lg transition">
          Save
        </button>
      </div>
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // --- RULES CHANGED POPUP LOGIC ---
  const rulesPopup = document.getElementById('rules-popup');
  const rulesReason = document.getElementById('rules-reason');
  const reasonText = document.getElementById('reason-text');
  const rulesPopupInner = document.getElementById('rules-popup-inner');
  const betaPopup = document.getElementById('beta-popup');
  const rollingText = document.getElementById('rolling-text');
  const mergedClose = document.getElementById('merged-close');
  const mergedCloseBeta = document.getElementById('merged-close-beta');
  let reasonShown = false;

  // GOATED BUTTON: change background to colorful gradient
  const goatedBtn = document.getElementById('goated-btn');
  if (goatedBtn) {
    goatedBtn.addEventListener('click', function() {
      document.body.classList.remove('bg-gray-900');
      document.body.style.background = 'linear-gradient(135deg, #ec4899 0%, #fde047 50%, #3b82f6 100%)';
      document.body.style.transition = 'background 0.7s cubic-bezier(.4,2,.6,1)';
    });
  }

  function showReason() {
    if (!reasonShown) {
      reasonText.textContent = 'I was too lazy.';
      reasonText.style.height = '2.5rem';
      rulesPopupInner.style.paddingBottom = '2.5rem';
      reasonShown = true;
    } else {
      reasonText.textContent = '';
      reasonText.style.height = '0';
      rulesPopupInner.style.paddingBottom = '';
      reasonShown = false;
    }
  }

  rulesReason.addEventListener('click', showReason);
  
  function showBetaVersion(container, text) {
    const originalHeight = container.clientHeight;
    const originalText = text.textContent;
    
    // Add height and change text
    container.style.height = (originalHeight + 80) + 'px';
    text.textContent = "This Is a Beta 1.2 Release";
    text.style.fontSize = '2rem';
    text.classList.add('font-extrabold');
    
    // Add text at the bottom
    const bottomText = document.createElement('div');
    bottomText.textContent = "I don't know why, try again";
    bottomText.className = "text-red-500 font-bold text-sm mt-4 animate-pulse";
    container.appendChild(bottomText);
    
    // Wait 2 seconds and then close
    return new Promise(resolve => {
      setTimeout(() => {
        container.removeChild(bottomText); // Clean up
        resolve();
      }, 2000);
    });
  }
  
  if (mergedClose) {
    mergedClose.addEventListener('click', function() {
      const container = rulesPopupInner;
      const text = container.querySelector('h2');
      
      showBetaVersion(container, text).then(() => {
        // Close both popups if visible
        if (rulesPopup) rulesPopup.style.display = 'none';
        if (betaPopup) betaPopup.style.display = 'none';
      });
    });
  }
  
  if (mergedCloseBeta) {
    mergedCloseBeta.addEventListener('click', function() {
      const container = betaPopup.querySelector('.rounded-2xl');
      const text = rollingText;
      
      showBetaVersion(container, text).then(() => {
        if (rulesPopup) rulesPopup.style.display = 'none';
        if (betaPopup) betaPopup.style.display = 'none';
      });
    });
  }
  // Show beta popup after rules
  if (mergedClose) {
    rulesPopup.addEventListener('transitionend', function() {
      if (rulesPopup.style.display === 'none') {
        betaPopup.style.display = 'flex';
        rollingText.classList.remove('animate-rolling');
        void rollingText.offsetWidth;
        rollingText.classList.add('animate-rolling');
      }
    });
  }

  // Beta popup close button
  const betaClose = document.getElementById('beta-close');
  if (betaClose) {
    betaClose.addEventListener('click', function() {
      betaPopup.style.display = 'none';
    });
  }

  // Prevent game interaction until popups are closed
  document.body.classList.add('overflow-hidden');
  function hidePopupsEnableGame() {
    document.body.classList.remove('overflow-hidden');
  }
  // Hide popups after beta
  betaPopup.addEventListener('transitionend', hidePopupsEnableGame);
  // Initialize the new Extended Chess AI
  const extendedAI = new ExtendedChessAIIntegration();

  const AI = {
    chooseMove(game, color) {
      // Use the new extended AI system
      return extendedAI.ai.chooseMove(game, color, 4);
    },

    // Legacy compatibility methods
    chooseMove2(game, color) {
      return this.chooseMove(game, color);
    },

    doubleCheckMove(game, color) {
      return this.chooseMove(game, color);
    }
  };

  // ----- Voice Assistant -----
  class ChessVoiceAssistant {
    constructor(config = {}) {
      this.enabled = config.enabled !== false;
      this.voice = null;
      this.rate = config.rate || 1.0;
      this.pitch = config.pitch || 1.0;
      this.volume = config.volume || 0.8;
      this.personality = config.personality || 'professional';
      
      this.announcements = {
        moves: config.announcements?.moves !== false,
        ai: config.announcements?.ai !== false,
        gameEvents: config.announcements?.gameEvents !== false,
        cheats: config.announcements?.cheats !== false
      };
      
      this.initVoice();
      this.initPhrases();
    }

    initVoice() {
      if ('speechSynthesis' in window) {
        this.loadVoices();
        speechSynthesis.addEventListener('voiceschanged', () => this.loadVoices());
      } else {
        console.warn('Speech synthesis not supported');
        this.enabled = false;
      }
    }

    loadVoices() {
      const voices = speechSynthesis.getVoices();
      const preferredVoices = [
        'Microsoft Zira Desktop', 'Google UK English Female', 'Alex', 'English (United States)'
      ];
      
      for (const preferred of preferredVoices) {
        const voice = voices.find(v => v.name.includes(preferred) || v.lang.includes(preferred));
        if (voice) {
          this.voice = voice;
          break;
        }
      }
      
      if (!this.voice && voices.length > 0) {
        this.voice = voices.find(v => v.lang.startsWith('en')) || voices[0];
      }
    }

    initPhrases() {
      this.phrases = {
        professional: {
          gameStart: ["Welcome to Chess Universe. Game initiated.", "Professional chess match beginning."],
          move: ["Move executed.", "Piece relocated.", "Strategic positioning."],
          capture: ["Piece captured.", "Material advantage gained."],
          check: ["Check! The king is under attack.", "Royal piece threatened."],
          checkmate: ["Checkmate! Game concluded.", "Victory achieved through superior strategy."],
          promotion: ["Pawn promotion successful.", "New queen on the battlefield."],
          aiMove: ["AI analyzing position.", "Computational move calculated."],
          cheat: ["Cheat function activated.", "Game modification engaged."]
        },
        casual: {
          gameStart: ["Let's play some chess!", "Game on!", "Ready to move some pieces?"],
          move: ["Nice move!", "There we go!", "Moving right along!"],
          capture: ["Got 'em!", "Piece down!", "That's gonna hurt!"],
          check: ["Uh oh, check!", "King's in trouble!", "Better watch out!"],
          checkmate: ["Game over!", "That's checkmate!", "Nice game!"],
          promotion: ["Pawn upgrade!", "Level up!", "New queen incoming!"],
          aiMove: ["Computer's thinking...", "AI's making a move!", "Bot's turn!"],
          cheat: ["Cheating activated!", "Breaking the rules!", "Hacker mode on!"]
        },
        dramatic: {
          gameStart: ["THE BATTLE BEGINS!", "Warriors, prepare for combat!", "The chess battlefield awaits!"],
          move: ["A BOLD MANEUVER!", "The pieces dance across the battlefield!", "STRATEGIC BRILLIANCE!"],
          capture: ["CONQUEST ACHIEVED!", "Another warrior falls!", "BLOOD ON THE BATTLEFIELD!"],
          check: ["THE KING IS IN MORTAL PERIL!", "Danger approaches the throne!", "THE REALM IS THREATENED!"],
          checkmate: ["TOTAL VICTORY!", "The kingdom has fallen!", "ABSOLUTE DOMINATION!"],
          promotion: ["A PEASANT BECOMES ROYALTY!", "RISE OF THE QUEEN!", "TRANSFORMATION COMPLETE!"],
          aiMove: ["THE MACHINE CALCULATES DOOM!", "Artificial intelligence strikes!", "THE ALGORITHM AWAKENS!"],
          cheat: ["REALITY ITSELF BENDS!", "The laws of chess crumble!", "FORBIDDEN POWER UNLEASHED!"]
        },
        funny: {
          gameStart: ["Time to embarrass yourself at chess!", "Let the blunders begin!", "Chess: where dreams go to die!"],
          move: ["Well, that happened.", "Interesting choice...", "Bold strategy, Cotton!"],
          capture: ["Nom nom nom!", "Ouch! That's gotta hurt!", "Another one bites the dust!"],
          check: ["Knock knock! Who's there? Check!", "Your king's having a bad day!", "Surprise!"],
          checkmate: ["Game over, man! Game over!", "That's a wrap!", "Better luck next time!"],
          promotion: ["From zero to hero!", "Rags to riches!", "The ugly duckling becomes a swan!"],
          aiMove: ["Beep boop, calculating your doom!", "The robot overlords are taking over!", "I for one welcome our AI chess masters!"],
          cheat: ["Rules? What rules?", "Cheater cheater pumpkin eater!", "Breaking bad... chess rules!"]
        }
      };
    }

    speak(text, category = 'general') {
      if (!this.enabled || !this.announcements[category] === false) return;
      if ('speechSynthesis' in window && this.voice) {
        speechSynthesis.cancel(); // Stop any current speech
        
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.voice = this.voice;
        utterance.rate = this.rate;
        utterance.pitch = this.pitch;
        utterance.volume = this.volume;
        
        speechSynthesis.speak(utterance);
      }
    }

    announceMove(piece, from, to, isCapture = false) {
      if (!this.announcements.moves) return;
      
      const phrases = this.phrases[this.personality];
      let message;
      
      if (isCapture) {
        message = this.randomPhrase(phrases.capture);
      } else {
        message = this.randomPhrase(phrases.move);
      }
      
      // Add move details for professional personality
      if (this.personality === 'professional') {
        message += ` ${piece} from ${from} to ${to}.`;
      }
      
      this.speak(message, 'moves');
    }

    announceGameEvent(event, details = '') {
      if (!this.announcements.gameEvents) return;
      
      const phrases = this.phrases[this.personality];
      let message = '';
      
      switch (event) {
        case 'gameStart':
          message = this.randomPhrase(phrases.gameStart);
          break;
        case 'check':
          message = this.randomPhrase(phrases.check);
          break;
        case 'checkmate':
          message = this.randomPhrase(phrases.checkmate);
          break;
        case 'promotion':
          message = this.randomPhrase(phrases.promotion);
          break;
        default:
          message = details;
      }
      
      this.speak(message, 'gameEvents');
    }

    announceAI(action) {
      if (!this.announcements.ai) return;
      
      const phrases = this.phrases[this.personality];
      const message = this.randomPhrase(phrases.aiMove);
      
      this.speak(message, 'ai');
    }

    announceCheat(cheatName) {
      if (!this.announcements.cheats) return;
      
      const phrases = this.phrases[this.personality];
      let message = this.randomPhrase(phrases.cheat);
      
      if (this.personality === 'professional') {
        message += ` ${cheatName} enabled.`;
      }
      
      this.speak(message, 'cheats');
    }

    randomPhrase(phrases) {
      return phrases[Math.floor(Math.random() * phrases.length)];
    }

    updateSettings(settings) {
      if (settings.personality) this.personality = settings.personality;
      if (settings.rate !== undefined) this.rate = settings.rate;
      if (settings.pitch !== undefined) this.pitch = settings.pitch;
      if (settings.volume !== undefined) this.volume = settings.volume / 100;
      if (settings.announcements) this.announcements = { ...this.announcements, ...settings.announcements };
    }

    toggle() {
      this.enabled = !this.enabled;
      return this.enabled;
    }

    testVoice() {
      const phrases = this.phrases[this.personality];
      const testMessage = this.randomPhrase(phrases.gameStart);
      this.speak(testMessage, 'gameEvents');
    }
  }

  // ----- Game Object -----
  const game = {
    board: Array(12).fill().map(() => Array(12).fill(null)),
    turn: 'white',
    selectedSquare: null,
    possibleMoves: [],
    moveHistory: [],
    capturedPieces: { white: [], black: [] },
    check: false,
    gameOver: false,
    lastMove: null,
    promotingPawn: null,
    vsComputer: false,
    computerSide: 'black',
    newGameClickCount: 0, // Easter egg counter
    advancedHintsEnabled: false,
    botMoveUsed: false, // Track if the one-time bot move has been used
    voiceAssistant: null, // Voice assistant instance

    init() {
      this.voiceAssistant = new ChessVoiceAssistant({
        enabled: false, // Start disabled
        personality: 'professional'
      });
      this.setupBoard();
      this.renderBoard();
      this.setupEventListeners();
      this.updateGameInfo();
      this.setupVoiceControls();
    },

    setupBoard() {
      // Set up pieces in the center 8x8 area of the 12x12 board (offset by 2)
      const offset = 2;
      
      // Black pieces (top)
      for (let col = 0; col < 8; col++) {
        this.board[offset + 1][offset + col] = { type: 'pawn', color: 'black', hasMoved: false };
      }
      this.board[offset + 0][offset + 0] = { type: 'rook', color: 'black', hasMoved: false };
      this.board[offset + 0][offset + 7] = { type: 'rook', color: 'black', hasMoved: false };
      this.board[offset + 0][offset + 1] = { type: 'knight', color: 'black' };
      this.board[offset + 0][offset + 6] = { type: 'knight', color: 'black' };
      this.board[offset + 0][offset + 2] = { type: 'bishop', color: 'black' };
      this.board[offset + 0][offset + 5] = { type: 'bishop', color: 'black' };
      this.board[offset + 0][offset + 3] = { type: 'queen', color: 'black' };
      this.board[offset + 0][offset + 4] = { type: 'king', color: 'black', hasMoved: false };

      // White pieces (bottom)
      for (let col = 0; col < 8; col++) {
        this.board[offset + 6][offset + col] = { type: 'pawn', color: 'white', hasMoved: false };
      }
      this.board[offset + 7][offset + 0] = { type: 'rook', color: 'white', hasMoved: false };
      this.board[offset + 7][offset + 7] = { type: 'rook', color: 'white', hasMoved: false };
      this.board[offset + 7][offset + 1] = { type: 'knight', color: 'white' };
      this.board[offset + 7][offset + 6] = { type: 'knight', color: 'white' };
      this.board[offset + 7][offset + 2] = { type: 'bishop', color: 'white' };
      this.board[offset + 7][offset + 5] = { type: 'bishop', color: 'white' };
      this.board[offset + 7][offset + 3] = { type: 'queen', color: 'white' };
      this.board[offset + 7][offset + 4] = { type: 'king', color: 'white', hasMoved: false };
      
      // Initialize special piece spawning variables
      this.specialPieceSpawned = false;
      this.specialPieceType = null;
      this.moveCount = 0;
      this.spawnTurn = Math.floor(Math.random() * 20) + 1; // Random turn between 1-20
    },

    renderBoard() {
      const boardElement = document.querySelector('.chess-board');
      boardElement.innerHTML = '';
      for (let row=0; row<12; row++) {
        for (let col=0; col<12; col++) {
          const square = document.createElement('div');
          
          // Check if this is a border square (outside the main 8x8 playing area)
          const isBorderSquare = row < 2 || row > 9 || col < 2 || col > 9;
          
          if (isBorderSquare) {
            // Border squares get a darker, more subdued color
            square.className = `square ${(row + col) % 2 === 0 ? 'border-light' : 'border-dark'}`;
          } else {
            // Main playing area uses normal chess colors
            square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
          }
          
          square.dataset.row = row;
          square.dataset.col = col;

          // Add notation only for the central 8x8 area (rows 2-9, cols 2-9)
          if (col === 2 && row >= 2 && row <= 9) {
            const rank = document.createElement('div');
            rank.className = 'notation rank';
            rank.textContent = 8 - (row - 2); // Convert to chess rank notation (8-1)
            square.appendChild(rank);
          }
          if (row === 9 && col >= 2 && col <= 9) {
            const file = document.createElement('div');
            file.className = 'notation file';
            file.textContent = String.fromCharCode(97 + (col - 2)); // Convert to chess file notation (a-h)
            square.appendChild(file);
          }

          const piece = this.board[row][col];
          if (piece) {
            const pieceElement = document.createElement('div');
            pieceElement.className = 'piece';
            pieceElement.dataset.piece = piece.type;
            pieceElement.dataset.color = piece.color;
            
            // Special styling for neutral special pieces
            if (piece.color === 'neutral' && piece.isSpecial) {
              pieceElement.style.cssText += `
                filter: drop-shadow(0 0 10px #ffd700) hue-rotate(180deg);
                animation: pulse 2s infinite, glow 3s ease-in-out infinite alternate;
                border-radius: 50%;
                border: 3px solid #ffd700;
              `;
            }
            
            // Handle special PNG pieces
            if (piece.type === 'lightpawn') {
              pieceElement.style.backgroundImage = `url('../img/Lightpawn.png')`;
              pieceElement.style.backgroundSize = 'contain';
              pieceElement.style.backgroundRepeat = 'no-repeat';
              pieceElement.style.backgroundPosition = 'center';
            } else if (piece.type === 'darkpawn') {
              pieceElement.style.backgroundImage = `url('../img/Darkpawn.png')`;
              pieceElement.style.backgroundSize = 'contain';
              pieceElement.style.backgroundRepeat = 'no-repeat';
              pieceElement.style.backgroundPosition = 'center';
            } else {
              // Regular SVG pieces
              const svg = this.getPieceSVG(piece.type, piece.color);
              pieceElement.style.backgroundImage = `url('data:image/svg+xml;utf8,${encodeURIComponent(svg)}')`;
            }
            
            square.appendChild(pieceElement);
          }
          boardElement.appendChild(square);
        }
      }
      document.querySelectorAll('.promotion-option .piece').forEach((el, idx) => {
        const types = ['queen','rook','bishop','knight'];
        const svg = this.getPieceSVG(types[idx], this.turn);
        el.style.backgroundImage = `url('data:image/svg+xml;utf8,${encodeURIComponent(svg)}')`;
      });
    },

    getPieceSVG(type, color) {
      // For lightpawn and darkpawn, return empty string since we'll use background images
      if (type === 'lightpawn' || type === 'darkpawn') {
        return '';
      }
      
      const pieceColor = color === 'white' ? '#fff' : '#000';
      const oppositeColor = color === 'white' ? '#000' : '#fff';
      switch(type) {
        case 'pawn':
          return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
            <path d="M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z"
            stroke="${oppositeColor}" fill="${pieceColor}" stroke-width="1.5" stroke-linecap="round"/></svg>`;
        case 'rook':
          return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
            <g fill="${pieceColor}" stroke="${oppositeColor}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 39h27v-3H9v3zM12 36v-4h21v4H12zM11 14V9h4v2h5V9h5v2h5V9h4v5"/>
              <path d="M34 14l-3 3H14l-3-3"/>
              <path d="M31 17v12.5H14V17"/>
              <path d="M31 29.5l1.5 2.5h-20l1.5-2.5z"/>
              <path d="M11 14h23"/>
            </g></svg>`;
        case 'knight':
          return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
            <g fill="${pieceColor}" stroke="${oppositeColor}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21"/>
              <path d="M24 18c.38 2.91-5.55 7.37-8 9-3 2-2.82 4.34-5 4-1.042-.94 1.41-3.04 0-3-1 0 .19 1.23-1 2-1 0-4.003 1-4-1 0-2 6-12 6-12s1.89-1.9 2-3.5c-.73-.994-.5-2-.5-3 1-1 3 2.5 3 2.5h2s.78-1.992 2.5-3c1 0 1 3 1 3"/>
              <circle cx="9.5" cy="25.5" r=".5" fill="${oppositeColor}"/>
              <circle cx="14.933" cy="15.75" r="1" fill="${oppositeColor}"/>
            </g></svg>`;
        case 'bishop':
          return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
            <g fill="${pieceColor}" stroke="${oppositeColor}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .5-3.39-.97-10.11.46-13.5-1-3.39 1.46-10.11.03-13.5 1-1.354.49-2.323.47-3-.5 1.354-1.94 3-2 3-2z"/>
              <path d="M15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z"/>
              <circle cx="22.5" cy="8.5" r="2.5" stroke="${oppositeColor}"/>
            </g></svg>`;
        case 'queen':
          return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
            <g fill="${pieceColor}" stroke="${oppositeColor}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 26c8.5-1.5 21-1.5 27 0l2.5-12.5L31 25l-.3-14.1-5.2 13.6-3-14.5-3 14.5-5.2-13.6L14 25 6.5 13.5 9 26z"/>
              <path d="M9 26c0 2 1.5 2 2.5 4 1 1.5 1 1 .5 3.5-1.5 1-1 2.5-1 2.5-1.5 1.5 0 2.5 0 2.5 6.5 1 16.5 1 23 0 0 0 1.5-1 0-2.5 0 0 .5-1.5-1-2.5-.5-2.5-.5-2 .5-3.5 1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z"/>
              <path d="M11.5 30c3.5-1 18.5-1 22 0m-21.5 1.5c2-1 15-1 17 0" fill="none"/>
            </g></svg>`;
        case 'king':
          return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45">
            <g fill="${pieceColor}" stroke="${oppositeColor}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M22.5 11.63V6M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5"/>
              <path d="M12.5 37c5.5 3.5 14.5 3.5 20 0v-7s9-4.5 6-10.5c-4-6.5-13.5-3.5-16 4V27v-3.5c-2.5-7.5-12-10.5-16-4-3 6 6 10.5 6 10.5v7"/>
              <path d="M20 8h5"/>
              <circle cx="22.5" cy="6.5" r="2" stroke="${oppositeColor}"/>
            </g></svg>`;
        default: return '';
      }
    },

    setupEventListeners() {
      const board = document.querySelector('.chess-board');

      document.getElementById('turn-indicator').addEventListener('click', () => {
        this.switchTurns();
        this.clearSelection();
        this.maybeAIMove();
      });

      document.getElementById('vs-computer').addEventListener('change', (e) => {
        this.vsComputer = e.target.checked;
        this.maybeAIMove(true);
      });

      document.getElementById('computer-side').addEventListener('change', (e) => {
        this.computerSide = e.target.value;
        this.maybeAIMove(true);
      });

      document.getElementById('force-ai').addEventListener('click', () => {
        this.maybeAIMove(true);
      });

      board.addEventListener('click', (e) => {
        if (this.gameOver) return;
        const square = e.target.closest('.square');
        if (!square) return;
        const row = parseInt(square.dataset.row);
        const col = parseInt(square.dataset.col);

        if (this.vsComputer && this.turn === this.computerSide) return;

        if (this.selectedSquare === null) {
          const piece = this.board[row][col];
          if (piece && piece.color === this.turn) {
            this.selectSquare(row, col);
          }
        } else {
          const [fromRow, fromCol] = this.selectedSquare;
          if (this.isValidMove(fromRow, fromCol, row, col)) {
            this.movePiece(fromRow, fromCol, row, col);
            this.clearSelection();
            this.maybeAIMove();
          } else {
            const piece = this.board[row][col];
            if (piece && piece.color === this.turn) {
              this.selectSquare(row, col);
            } else {
              this.clearSelection();
            }
          }
        }
      });

      document.getElementById('new-game').addEventListener('click', () => {
        this.newGameClickCount++;
        console.log('New game clicked:', this.newGameClickCount, 'times');
        
        if (this.newGameClickCount >= 5 && !this.advancedHintsEnabled) {
          this.enableAdvancedHints();
        } else {
          this.resetGame();
          this.maybeAIMove(true);
        }
      });

      document.getElementById('undo-move').addEventListener('click', () => {
        this.undoMove();
      });

      document.querySelectorAll('.promotion-option').forEach(option => {
        option.addEventListener('click', (e) => {
          const pieceType = e.currentTarget.dataset.piece;
          this.completePromotion(pieceType);
        });
      });
    },

    setupVoiceControls() {
      const toggleButton = document.getElementById('toggle-voice');
      const settingsButton = document.getElementById('voice-settings');
      const modal = document.getElementById('voice-settings-modal');
      const closeButton = document.getElementById('voice-settings-close');
      const saveButton = document.getElementById('voice-settings-save');
      const testButton = document.getElementById('test-voice');

      // Toggle voice assistant
      toggleButton.addEventListener('click', () => {
        const enabled = this.voiceAssistant.toggle();
        toggleButton.textContent = `üé§ Voice: ${enabled ? 'ON' : 'OFF'}`;
        toggleButton.className = enabled 
          ? 'bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded-lg transition'
          : 'bg-red-600 hover:bg-red-700 text-white py-2 px-4 rounded-lg transition';
        
        if (enabled) {
          this.voiceAssistant.announceGameEvent('gameStart');
        }
      });

      // Show settings modal
      settingsButton.addEventListener('click', () => {
        this.loadVoiceSettings();
        modal.classList.remove('hidden');
      });

      // Close modal
      closeButton.addEventListener('click', () => {
        modal.classList.add('hidden');
      });

      // Save settings
      saveButton.addEventListener('click', () => {
        this.saveVoiceSettings();
        modal.classList.add('hidden');
      });

      // Test voice
      testButton.addEventListener('click', () => {
        this.voiceAssistant.testVoice();
      });

      // Update range displays
      const setupRangeDisplay = (rangeId, displayId, suffix = '') => {
        const range = document.getElementById(rangeId);
        const display = document.getElementById(displayId);
        range.addEventListener('input', () => {
          display.textContent = range.value + suffix;
        });
      };

      setupRangeDisplay('voice-speed', 'speed-value', 'x');
      setupRangeDisplay('voice-pitch', 'pitch-value');
      setupRangeDisplay('voice-volume', 'volume-value', '%');
    },

    loadVoiceSettings() {
      document.getElementById('voice-personality').value = this.voiceAssistant.personality;
      document.getElementById('voice-speed').value = this.voiceAssistant.rate;
      document.getElementById('voice-pitch').value = this.voiceAssistant.pitch;
      document.getElementById('voice-volume').value = this.voiceAssistant.volume * 100;
      
      document.getElementById('announce-moves').checked = this.voiceAssistant.announcements.moves;
      document.getElementById('announce-ai').checked = this.voiceAssistant.announcements.ai;
      document.getElementById('announce-game-events').checked = this.voiceAssistant.announcements.gameEvents;
      document.getElementById('announce-cheats').checked = this.voiceAssistant.announcements.cheats;

      // Update displays
      document.getElementById('speed-value').textContent = this.voiceAssistant.rate + 'x';
      document.getElementById('pitch-value').textContent = this.voiceAssistant.pitch;
      document.getElementById('volume-value').textContent = (this.voiceAssistant.volume * 100) + '%';
    },

    saveVoiceSettings() {
      const settings = {
        personality: document.getElementById('voice-personality').value,
        rate: parseFloat(document.getElementById('voice-speed').value),
        pitch: parseFloat(document.getElementById('voice-pitch').value),
        volume: parseInt(document.getElementById('voice-volume').value),
        announcements: {
          moves: document.getElementById('announce-moves').checked,
          ai: document.getElementById('announce-ai').checked,
          gameEvents: document.getElementById('announce-game-events').checked,
          cheats: document.getElementById('announce-cheats').checked
        }
      };
      
      this.voiceAssistant.updateSettings(settings);
    },

    selectSquare(row, col) {
      this.clearSelection();
      this.selectedSquare = [row, col];
      const square = this.getSquareElement(row, col);
      square.classList.add('highlight');
      this.possibleMoves = this.calculatePossibleMoves(row, col);
      this.showPossibleMoves();
    },

    clearSelection() {
      if (this.selectedSquare) {
        const [row, col] = this.selectedSquare;
        const square = this.getSquareElement(row, col);
        square.classList.remove('highlight');
      }
      this.hidePossibleMoves();
      this.selectedSquare = null;
      this.possibleMoves = [];
    },

    showPossibleMoves() {
      this.possibleMoves.forEach(([row, col]) => {
        const square = this.getSquareElement(row, col);
        const marker = document.createElement('div');
        marker.className = 'possible-move';
        square.appendChild(marker);
      });
    },

    hidePossibleMoves() { document.querySelectorAll('.possible-move').forEach(m => m.remove()); },

    calculatePossibleMoves(row, col) {
      const piece = this.board[row][col];
      if (!piece) return [];
      const moves = [];
      const color = piece.color;
      const opponentColor = color === 'white' ? 'black' : 'white';

      const isInBounds = (r,c)=> r>=0 && r<12 && c>=0 && c<12;
      const addDirectionalMoves = (dr, dc) => {
        let r=row+dr, c=col+dc;
        while (isInBounds(r,c)) {
          if (!this.board[r][c]) moves.push([r,c]);
          else { if (this.board[r][c].color === opponentColor || this.board[r][c].color === 'neutral') moves.push([r,c]); break; }
          r+=dr; c+=dc;
        }
      };

      switch (piece.type) {
        case 'pawn': {
          const dir = color === 'white' ? -1 : 1;
          if (isInBounds(row+dir,col) && !this.board[row+dir][col]) {
            moves.push([row+dir, col]);
            if (!piece.hasMoved && isInBounds(row+2*dir,col) && !this.board[row+2*dir][col] && !this.board[row+dir][col]) {
              moves.push([row+2*dir, col]);
            }
          }
          for (const dc of [-1,1]) {
            const r=row+dir, c=col+dc;
            if (!isInBounds(r,c)) continue;
            if (this.board[r][c] && (this.board[r][c].color===opponentColor || this.board[r][c].color==='neutral')) moves.push([r,c]);
            if (!this.board[r][c] && this.lastMove &&
                this.lastMove.piece.type==='pawn' && this.lastMove.piece.color===opponentColor &&
                Math.abs(this.lastMove.from.row - this.lastMove.to.row)===2 &&
                this.lastMove.to.row===row && this.lastMove.to.col===c) {
              moves.push([r,c]);
            }
          }
          break;
        }
        case 'lightpawn': {
          // Lightpawn moves diagonally forward only
          const dir = color === 'white' ? -1 : 1; // White moves up (negative), black moves down (positive)
          for (const dc of [-1, 1]) { // Diagonal left and right
            const r = row + dir, c = col + dc;
            if (isInBounds(r, c)) {
              // Can move to empty squares or capture enemy pieces or neutral pieces
              if (!this.board[r][c] || (this.board[r][c] && (this.board[r][c].color === opponentColor || this.board[r][c].color === 'neutral'))) {
                moves.push([r, c]);
              }
            }
          }
          break;
        }
        case 'darkpawn': {
          // Darkpawn moves diagonally forward only
          const dir = color === 'white' ? -1 : 1; // White moves up (negative), black moves down (positive)
          for (const dc of [-1, 1]) { // Diagonal left and right
            const r = row + dir, c = col + dc;
            if (isInBounds(r, c)) {
              // Can move to empty squares or capture enemy pieces or neutral pieces
              if (!this.board[r][c] || (this.board[r][c] && (this.board[r][c].color === opponentColor || this.board[r][c].color === 'neutral'))) {
                moves.push([r, c]);
              }
            }
          }
          break;
        }
        case 'rook': [[1,0],[-1,0],[0,1],[0,-1]].forEach(d=>addDirectionalMoves(...d)); break;
        case 'knight':
          [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(([dr,dc])=>{
            const r=row+dr,c=col+dc;
            if (isInBounds(r,c) && (!this.board[r][c] || this.board[r][c].color===opponentColor || this.board[r][c].color==='neutral')) moves.push([r,c]);
          }); break;
        case 'bishop': [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(d=>addDirectionalMoves(...d)); break;
        case 'queen': [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(d=>addDirectionalMoves(...d)); break;
        case 'king':
          for (let r=row-1; r<=row+1; r++) for (let c=col-1; c<=col+1; c++) {
            if ((r!==row || c!==col) && isInBounds(r,c) && (!this.board[r][c] || this.board[r][c].color===opponentColor || this.board[r][c].color==='neutral')) moves.push([r,c]);
          }
          break;
      }

      return moves.filter(([tr,tc]) => {
        const original = this.board[tr][tc];
        this.board[tr][tc] = this.board[row][col];
        this.board[row][col] = null;
        const inCheck = this.isKingInCheck(color);
        this.board[row][col] = this.board[tr][tc];
        this.board[tr][tc] = original;
        return !inCheck;
      });
    },

    isValidMove(fr,fc,tr,tc) { return this.possibleMoves.some(([r,c]) => r===tr && c===tc); },

    movePiece(fr,fc,tr,tc) {
      const piece = this.board[fr][fc];
      // Pawn promotion now occurs at rows 2 (white promotes) and 9 (black promotes) due to the 12x12 board with 2-square offset
      // Also handle lightpawn and darkpawn promotion
      const isPawnPromotion = (piece.type==='pawn' && ((piece.color==='white' && tr===2) || (piece.color==='black' && tr===9))) ||
                              (piece.type==='lightpawn' && ((piece.color==='white' && tr===2) || (piece.color==='black' && tr===9))) ||
                              (piece.type==='darkpawn' && ((piece.color==='white' && tr===2) || (piece.color==='black' && tr===9)));
      const move = {
        from:{row:fr,col:fc},
        to:{row:tr,col:tc},
        piece:{...piece},
        captured: this.board[tr][tc] ? {...this.board[tr][tc]} :
                  (piece.type==='pawn' && fc!==tc && !this.board[tr][tc]) ? {...this.board[fr][tc]} : null,
        promotion: isPawnPromotion
      };

      if (this.board[tr][tc]) {
        const capturedPiece = this.board[tr][tc];
        
        // Special handling for neutral special pieces
        if (capturedPiece.color === 'neutral' && capturedPiece.isSpecial) {
          // Convert the captured special piece to the capturing player's color
          const claimedPiece = {
            type: capturedPiece.type,
            color: this.turn,
            hasMoved: false,
            isSpecial: true,
            claimed: true
          };
          
          // Place the claimed piece at the target position
          this.board[tr][tc] = claimedPiece;
          this.board[fr][fc] = null;
          
          // Show claim notification
          this.showSpecialPieceClaimNotification(capturedPiece.type, this.turn);
          
          if (piece.type==='pawn' || piece.type==='lightpawn' || piece.type==='darkpawn' || piece.type==='rook' || piece.type==='king') piece.hasMoved = true;
          
          this.lastMove = move;
          this.moveHistory.push(move);
          this.switchTurns();
          this.checkGameStatus();
          this.renderBoard();
          this.maybeAIMove();
          return;
        } else {
          // Regular capture
          this.capturedPieces[this.turn].push(capturedPiece);
          this.updateCapturedPiecesDisplay();
        }
      } else if (piece.type==='pawn' && fc!==tc && !this.board[tr][tc]) {
        const capturedPawnRow = fr;
        const capturedPawnCol = tc;
        const capturedPiece = this.board[capturedPawnRow][capturedPawnCol];
        this.capturedPieces[this.turn].push(capturedPiece);
        this.board[capturedPawnRow][capturedPawnCol] = null;
        this.updateCapturedPiecesDisplay();
      }

      this.board[tr][tc] = piece;
      this.board[fr][fc] = null;

      if (piece.type==='pawn' || piece.type==='lightpawn' || piece.type==='darkpawn' || piece.type==='rook' || piece.type==='king') piece.hasMoved = true;

      if (isPawnPromotion) {
        this.promotingPawn = { row: tr, col: tc };
        this.showPromotionModal();
        this.voiceAssistant?.announceGameEvent('promotion');
      } else {
        this.switchTurns();
        this.lastMove = move;
        this.moveHistory.push(move);
        this.checkGameStatus();
      }

      // Voice announcement for the move
      const isCapture = move.captured !== null;
      const fromSquare = String.fromCharCode(97 + (fc - 2)) + (10 - fr); // Convert to chess notation
      const toSquare = String.fromCharCode(97 + (tc - 2)) + (10 - tr);
      this.voiceAssistant?.announceMove(piece.type, fromSquare, toSquare, isCapture);

      this.renderBoard();
    },

    showPromotionModal() { document.getElementById('promotion-modal').classList.remove('hidden'); },
    hidePromotionModal() { document.getElementById('promotion-modal').classList.add('hidden'); },

    completePromotion(pieceType) {
      if (!this.promotingPawn) return;
      const { row, col } = this.promotingPawn;
      this.board[row][col].type = pieceType;
      this.promotingPawn = null;
      this.hidePromotionModal();
      this.switchTurns();
      this.checkGameStatus();
      this.renderBoard();
      this.maybeAIMove();
    },

    switchTurns() {
      this.turn = this.turn === 'white' ? 'black' : 'white';
      this.moveCount++;
      
      // Check if it's time to spawn special piece
      this.checkSpecialPieceSpawn();
      
      this.updateGameInfo();
      document.getElementById('turn-indicator').style.backgroundColor = this.turn === 'white' ? 'white' : 'black';
    },

    checkSpecialPieceSpawn() {
      if (!this.specialPieceSpawned && this.moveCount === this.spawnTurn) {
        this.spawnSpecialPiece();
      }
    },

    spawnSpecialPiece() {
      // Randomly choose between lightpawn or darkpawn
      const specialPieces = ['lightpawn', 'darkpawn'];
      this.specialPieceType = specialPieces[Math.floor(Math.random() * specialPieces.length)];
      
      // Find empty squares on the board
      const emptySquares = [];
      for (let r = 0; r < 12; r++) {
        for (let c = 0; c < 12; c++) {
          if (!this.board[r][c]) {
            emptySquares.push([r, c]);
          }
        }
      }
      
      if (emptySquares.length > 0) {
        // Pick random empty square
        const randomSquare = emptySquares[Math.floor(Math.random() * emptySquares.length)];
        const [r, c] = randomSquare;
        
        // Spawn the special piece as neutral (no color initially)
        this.board[r][c] = { 
          type: this.specialPieceType, 
          color: 'neutral', 
          hasMoved: false,
          isSpecial: true 
        };
        
        this.specialPieceSpawned = true;
        
        // Show dramatic notification
        this.showSpecialPieceNotification(this.specialPieceType, r, c);
        
        // Re-render board to show the new piece
        this.renderBoard();
        
        console.log(`üåü SPECIAL PIECE SPAWNED: ${this.specialPieceType} at ${r},${c} on move ${this.moveCount}!`);
      }
    },

    showSpecialPieceNotification(pieceType, row, col) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(45deg, #ff6b6b, #ffd93d, #6bcf7f, #4d72fa, #9c88ff);
        background-size: 400% 400%;
        animation: rainbow 2s ease infinite, bounce 0.6s ease-out;
        color: white;
        padding: 30px;
        border-radius: 20px;
        text-align: center;
        font-size: 24px;
        font-weight: bold;
        z-index: 1000;
        border: 4px solid #fff;
        box-shadow: 0 0 30px rgba(255,255,255,0.8);
        max-width: 400px;
      `;
      
      const pieceName = pieceType === 'lightpawn' ? 'LIGHTPAWN' : 'DARKPAWN';
      notification.innerHTML = `
        <div style="font-size: 48px; margin-bottom: 15px;">‚ú®</div>
        <div style="font-size: 28px; margin-bottom: 10px;">SPECIAL PIECE SPAWNED!</div>
        <div style="font-size: 20px; margin-bottom: 15px;">${pieceName}</div>
        <div style="font-size: 16px; opacity: 0.9;">First to capture it claims its power!</div>
        <div style="font-size: 14px; margin-top: 10px;">Located at row ${row + 1}, column ${String.fromCharCode(97 + col)}</div>
      `;
      
      document.body.appendChild(notification);
      
      // Remove after 5 seconds
      setTimeout(() => {
        notification.style.opacity = '0';
        notification.style.transform = 'translate(-50%, -50%) scale(0.8)';
        setTimeout(() => notification.remove(), 500);
      }, 5000);
      
      // Add rainbow animation CSS if not already added
      if (!document.getElementById('special-animations')) {
        const style = document.createElement('style');
        style.id = 'special-animations';
        style.textContent = `
          @keyframes rainbow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
          }
        `;
        document.head.appendChild(style);
      }
    },

    showSpecialPieceClaimNotification(pieceType, playerColor) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(45deg, #ffd700, #ffed4e, #fff700, #ffe135, #ffd700);
        background-size: 400% 400%;
        animation: rainbow 2s ease infinite, bounce 0.6s ease-out;
        color: #333;
        padding: 30px;
        border-radius: 20px;
        text-align: center;
        font-size: 24px;
        font-weight: bold;
        z-index: 1000;
        border: 4px solid #fff;
        box-shadow: 0 0 30px rgba(255,215,0,0.8);
        max-width: 400px;
      `;
      
      const pieceName = pieceType === 'lightpawn' ? 'LIGHTPAWN' : 'DARKPAWN';
      const playerName = playerColor === 'white' ? 'WHITE' : 'BLACK';
      notification.innerHTML = `
        <div style="font-size: 48px; margin-bottom: 15px;">üèÜ</div>
        <div style="font-size: 28px; margin-bottom: 10px;">SPECIAL PIECE CLAIMED!</div>
        <div style="font-size: 20px; margin-bottom: 15px;">${playerName} claims ${pieceName}!</div>
        <div style="font-size: 16px; opacity: 0.9;">The power is now yours to command!</div>
      `;
      
      document.body.appendChild(notification);
      
      // Remove after 4 seconds
      setTimeout(() => {
        notification.style.opacity = '0';
        notification.style.transform = 'translate(-50%, -50%) scale(0.8)';
        setTimeout(() => notification.remove(), 500);
      }, 4000);
    },

    isKingInCheck(color) {
      let kingRow, kingCol;
      for (let r=0;r<12;r++){
        for (let c=0;c<12;c++){
          const p=this.board[r][c];
          if (p && p.type==='king' && p.color===color){ kingRow=r; kingCol=c; break; }
        }
        if (kingRow!==undefined) break;
      }
      const opp = color==='white' ? 'black' : 'white';
      for (let r=0;r<12;r++){
        for (let c=0;c<12;c++){
          const p=this.board[r][c];
          if (p && p.color===opp){
            const moves=this.calculateRawMoves(r,c);
            if (moves.some(([tr,tc])=>tr===kingRow && tc===kingCol)) return true;
          }
        }
      }
      return false;
    },

    calculateRawMoves(row,col){
      const piece = this.board[row][col];
      if (!piece) return [];
      const color = piece.color;
      const opp = color==='white' ? 'black' : 'white';
      const isInBounds=(r,c)=> r>=0 && r<12 && c>=0 && c<12;
      const moves=[];
      const addDir=(dr,dc)=>{ let r=row+dr,c=col+dc; while(isInBounds(r,c)){ if(!this.board[r][c]) moves.push([r,c]); else { if(this.board[r][c].color===opp || this.board[r][c].color==='neutral') moves.push([r,c]); break; } r+=dr; c+=dc; } };

      switch(piece.type){
        case 'pawn': {
          const dir=color==='white'?-1:1;
          if (isInBounds(row+dir,col) && !this.board[row+dir][col]){
            moves.push([row+dir,col]);
            if(!piece.hasMoved && isInBounds(row+2*dir,col) && !this.board[row+2*dir][col]) moves.push([row+2*dir,col]);
          }
          for (const dc of [-1,1]){
            const r=row+dir, c=col+dc;
            if (isInBounds(r,c) && this.board[r][c] && (this.board[r][c].color===opp || this.board[r][c].color==='neutral')) moves.push([r,c]);
          }
          break;
        }
        case 'lightpawn': {
          const dir=color==='white'?-1:1;
          for (const dc of [-1,1]){
            const r=row+dir, c=col+dc;
            if (isInBounds(r,c) && (!this.board[r][c] || (this.board[r][c] && (this.board[r][c].color===opp || this.board[r][c].color==='neutral')))) moves.push([r,c]);
          }
          break;
        }
        case 'darkpawn': {
          const dir=color==='white'?-1:1;
          for (const dc of [-1,1]){
            const r=row+dir, c=col+dc;
            if (isInBounds(r,c) && (!this.board[r][c] || (this.board[r][c] && (this.board[r][c].color===opp || this.board[r][c].color==='neutral')))) moves.push([r,c]);
          }
          break;
        }
        case 'rook': [[1,0],[-1,0],[0,1],[0,-1]].forEach(d=>addDir(...d)); break;
        case 'knight': [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(([dr,dc])=>{
          const r=row+dr,c=col+dc; if(isInBounds(r,c) && (!this.board[r][c] || this.board[r][c].color===opp || this.board[r][c].color==='neutral')) moves.push([r,c]);
        }); break;
        case 'bishop': [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(d=>addDir(...d)); break;
        case 'queen': [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(d=>addDir(...d)); break;
        case 'king':
          for (let r=row-1;r<=row+1;r++) for (let c=col-1;c<=col+1;c++){
            if ((r!==row || c!==col) && isInBounds(r,c) && (!this.board[r][c] || this.board[r][c].color===opp || this.board[r][c].color==='neutral')) moves.push([r,c]);
          }
          break;
      }
      return moves;
    },

    checkGameStatus() {
      const inCheck = this.isKingInCheck(this.turn);
      this.highlightKingInCheck(this.turn, inCheck);

      let hasLegal=false;
      for (let r=0;r<12;r++){
        for (let c=0;c<12;c++){
          const p=this.board[r][c];
          if (p && p.color===this.turn){
            const mv=this.calculatePossibleMoves(r,c);
            if (mv.length>0){ hasLegal=true; break; }
          }
        }
        if (hasLegal) break;
      }
      if (!hasLegal){
        this.gameOver = true;
        if (inCheck) {
          document.getElementById('game-status').textContent = `Checkmate - ${this.turn==='white'?'Black':'White'} wins!`;
          this.voiceAssistant?.announceGameEvent('checkmate');
        } else {
          document.getElementById('game-status').textContent = 'Stalemate - Draw!';
          this.voiceAssistant?.announceGameEvent('gameEvents', 'Stalemate! The game is a draw.');
        }
      } else if (inCheck){
        this.check = true;
        document.getElementById('game-status').textContent = 'Check!';
        this.voiceAssistant?.announceGameEvent('check');
      } else {
        this.check = false;
        if (!this.gameOver) document.getElementById('game-status').textContent = 'Playing';
      }
    },

    updateGameInfo() {
      document.getElementById('current-turn').textContent = this.turn === 'white' ? 'White' : 'Black';
      document.getElementById('turn-indicator').style.backgroundColor = this.turn === 'white' ? 'white' : 'black';
      if (this.check) document.getElementById('game-status').textContent = 'Check!';
      else if (!this.gameOver) document.getElementById('game-status').textContent = 'Playing';
    },

    updateCapturedPiecesDisplay() {
      const container = document.getElementById('captured-pieces');
      container.innerHTML = '';
      for (const color of ['white','black']) {
        this.capturedPieces[color].forEach(piece=>{
          const el=document.createElement('div');
          el.className='piece w-4 h-4 md:w-6 md:h-6';
          const svg=this.getPieceSVG(piece.type, color==='white'?'black':'white');
          el.style.backgroundImage=`url('data:image/svg+xml;utf8,${encodeURIComponent(svg)}')`;
          container.appendChild(el);
        });
      }
    },

    undoMove() {
      if (this.moveHistory.length===0) return;
      const lastMove = this.moveHistory.pop();
      this.board[lastMove.from.row][lastMove.from.col] = lastMove.piece;
      if (lastMove.captured){
        this.board[lastMove.to.row][lastMove.to.col] = lastMove.captured;
        const idx = this.capturedPieces[this.turn].findIndex(p=>p.type===lastMove.captured.type && p.color===lastMove.captured.color);
        if (idx!==-1) this.capturedPieces[this.turn].splice(idx,1);
      } else {
        this.board[lastMove.to.row][lastMove.to.col] = null;
      }
      this.switchTurns();
      this.gameOver=false;
      this.check=false;
      this.updateGameInfo();
      this.updateCapturedPiecesDisplay();
      this.renderBoard();
    },

    resetGame() {
      this.board = Array(8).fill().map(()=>Array(8).fill(null));
      this.setupBoard();
      this.turn = 'white';
      this.selectedSquare = null;
      this.possibleMoves = [];
      this.moveHistory = [];
      this.capturedPieces = { white: [], black: [] };
      this.check=false;
      this.gameOver=false;
      this.promotingPawn=null;
      this.updateGameInfo();
      this.updateCapturedPiecesDisplay();
      this.renderBoard();
      this.hidePromotionModal();
      this.voiceAssistant?.announceGameEvent('gameStart');
    },

    getSquareElement(r,c){ return document.querySelector(`.square[data-row="${r}"][data-col="${c}"]`); },

    highlightKingInCheck(color, inCheck){
      let kr,kc;
      for (let r=0;r<12;r++){
        for (let c=0;c<12;c++){
          const p=this.board[r][c];
          if (p && p.type==='king' && p.color===color){ kr=r; kc=c; break; }
        }
        if (kr!==undefined) break;
      }
      const sq = this.getSquareElement(kr,kc);
      if (!sq) return;
      if (inCheck) sq.classList.add('king-in-check'); else sq.classList.remove('king-in-check');
    },

    async maybeAIMove(force=false){
      if (!this.vsComputer) return;
      if (this.gameOver) return;
      if (this.turn !== this.computerSide) return;
      
      console.log('Making AI move...');
      const difficulty = 3; // Medium difficulty
      
      try {
        const move = await extendedAI.makeAIMove(this, this.turn, difficulty);
        if (move) {
          console.log('AI move received:', extendedAI.moveToString(move));
          this.voiceAssistant?.announceAI('AI move');
          this.movePiece(move.from.r, move.from.c, move.to.r, move.to.c);
          if (this.promotingPawn && this.turn !== this.computerSide) {
            this.completePromotion('queen');
          }
        } else {
          console.log('AI could not find a move');
        }
      } catch (error) {
        console.error('AI move error:', error);
        // Fallback to old AI if new one fails
        setTimeout(()=>{
          const move = AI.chooseMove(this, this.turn);
          if (move) {
            this.movePiece(move.from.r, move.from.c, move.to.r, move.to.c);
            if (this.promotingPawn && this.turn !== this.computerSide) {
              this.completePromotion('queen');
            }
          }
        }, force ? 150 : 250);
      }
    },

    // Advanced Hints Feature
    enableAdvancedHints() {
      console.log('üöÄ Advanced Hints Mode Activated!');
      this.advancedHintsEnabled = true;
      this.voiceAssistant?.announceCheat('Advanced Hints Mode');
      
      // Replace new game button with advanced hints button
      const newGameBtn = document.getElementById('new-game');
      const advancedHintsBtn = document.getElementById('advanced-hints-btn');
      const botMoveBtn = document.getElementById('bot-move-btn');
      
      newGameBtn.style.display = 'none';
      advancedHintsBtn.classList.remove('hidden');
      botMoveBtn.classList.remove('hidden');
      
      // Add event listeners
      advancedHintsBtn.addEventListener('click', () => this.showAdvancedHints());
      botMoveBtn.addEventListener('click', () => this.makeBotMove());
      
      // Show notification
      this.showAdvancedHintsNotification();
      
      // Reset game
      this.resetGame();
      this.maybeAIMove(true);
    },

    showAdvancedHintsNotification() {
      // Create notification element
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(45deg, #8b5cf6, #ec4899);
        color: white;
        padding: 20px 30px;
        border-radius: 15px;
        font-size: 18px;
        font-weight: bold;
        text-align: center;
        z-index: 1000;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        animation: bounce 0.5s ease-out;
      `;
      notification.innerHTML = `
        üéâ ADVANCED HINTS UNLOCKED! üéâ<br>
        <small style="font-size: 14px; opacity: 0.9;">
          ‚Ä¢ Top 2 move suggestions<br>
          ‚Ä¢ Bot move predictions<br>
          ‚Ä¢ One-time bot move control
        </small>
      `;
      
      document.body.appendChild(notification);
      
      // Remove after 4 seconds
      setTimeout(() => {
        notification.style.animation = 'fadeOut 0.5s ease-out';
        setTimeout(() => notification.remove(), 500);
      }, 4000);
      
      // Add CSS for animations
      const style = document.createElement('style');
      style.textContent = `
        @keyframes bounce {
          0% { transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
          50% { transform: translate(-50%, -50%) scale(1.05); }
          100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        @keyframes fadeOut {
          to { opacity: 0; transform: translate(-50%, -50%) scale(0.95); }
        }
      `;
      document.head.appendChild(style);
    },

    showAdvancedHints() {
      console.log('üîÆ Advanced Hints requested');
      if (this.gameOver) {
        console.log('Game is over, not showing hints');
        return;
      }
      
      // Clear existing hints
      this.clearHints();
      
      // Get top 2 moves using simple AI evaluation
      const topMoves = this.getTopMoves(2);
      
      if (topMoves.length >= 1 && topMoves[0].move) {
        this.displayAdvancedHint(topMoves[0].move, 'primary');
      }
      if (topMoves.length >= 2 && topMoves[1].move) {
        this.displayAdvancedHint(topMoves[1].move, 'secondary');
      }
      
      // Show prediction arrows for potential bot responses
      if (topMoves.length >= 1 && topMoves[0].move) {
        this.showBotPredictions(topMoves[0].move);
      }
    },

    getTopMoves(count = 2) {
      console.log('Calculating top', count, 'moves with Extended AI...');
      try {
        return extendedAI.getTopMoves(this, this.turn, count);
      } catch (error) {
        console.error('Extended AI failed, using fallback:', error);
        // Fallback to original method
        const moves = this.generateAllMoves(this.turn);
        const evaluatedMoves = [];
        
        // Evaluate each move using simple heuristics
        for (const move of moves) {
          const score = this.evaluateMove(move);
          evaluatedMoves.push({ move: { ...move }, score });
        }
        
        // Sort by score (best first)
        evaluatedMoves.sort((a, b) => {
          return this.turn === 'white' ? b.score - a.score : a.score - b.score;
        });
        
        return evaluatedMoves.slice(0, count);
      }
    },

    evaluateMove(move) {
      // Simple move evaluation
      let score = 0;
      
      // Capture bonus
      if (this.board[move.to.r][move.to.c]) {
        const capturedPiece = this.board[move.to.r][move.to.c];
        const pieceValues = { pawn: 100, knight: 300, bishop: 300, rook: 500, queen: 900, king: 10000 };
        score += pieceValues[capturedPiece.type] || 0;
      }
      
      // Center control bonus
      const centerDistance = Math.abs(move.to.r - 3.5) + Math.abs(move.to.c - 3.5);
      score += (7 - centerDistance) * 10;
      
      // Random factor for variety
      score += Math.random() * 50;
      
      return score;
    },

    generateAllMoves(color) {
      const moves = [];
      for (let r = 0; r < 12; r++) {
        for (let c = 0; c < 12; c++) {
          const piece = this.board[r][c];
          if (piece && piece.color === color) {
            const pieceMoves = this.calculatePossibleMoves(r, c);
            for (const [toR, toC] of pieceMoves) {
              moves.push({ from: { r, c }, to: { r: toR, c: toC }, piece });
            }
          }
        }
      }
      return moves;
    },

    displayAdvancedHint(move, type) {
      // Validate move object structure
      if (!move || !move.from || !move.to || 
          typeof move.from.r === 'undefined' || typeof move.from.c === 'undefined' ||
          typeof move.to.r === 'undefined' || typeof move.to.c === 'undefined') {
        console.error('Invalid move object for hint:', move);
        return;
      }

      const fromSquare = this.getSquareElement(move.from.r, move.from.c);
      const toSquare = this.getSquareElement(move.to.r, move.to.c);
      
      if (fromSquare && toSquare) {
        const className = type === 'primary' ? 'hint-primary' : 'hint-secondary';
        fromSquare.classList.add(className);
        toSquare.classList.add(className);
        
        console.log(`üí° ${type} hint:`, move.from, '‚Üí', move.to);
      }
    },

    showBotPredictions(playerMove) {
      if (!playerMove) return;
      
      console.log('ü§ñ Predicting bot responses...');
      
      // Simulate the player's move
      const originalPiece = this.board[playerMove.to.r][playerMove.to.c];
      const movingPiece = this.board[playerMove.from.r][playerMove.from.c];
      
      this.board[playerMove.to.r][playerMove.to.c] = movingPiece;
      this.board[playerMove.from.r][playerMove.from.c] = null;
      
      // Get bot's best responses using Extended AI
      const botColor = this.turn === 'white' ? 'black' : 'white';
      
      try {
        // Get top 3-5 moves from Extended AI
        const topBotMoves = extendedAI.getTopMoves(this, botColor, 5);
        
        if (topBotMoves.length > 0) {
          // Create predictions with confidence levels: 90%, 75%, 60%, 50%, 40%
          const confidenceLevels = [90, 75, 60, 50, 40];
          
          for (let i = 0; i < Math.min(topBotMoves.length, 5); i++) {
            const confidence = confidenceLevels[i];
            const botMove = topBotMoves[i].move;
            
            if (botMove && botMove.from && botMove.to) {
              this.createPredictionArrow(botMove.from, botMove.to, confidence, i);
              console.log(`üéØ Prediction ${i + 1}: ${confidence}% chance of ${botMove.from.r},${botMove.from.c} ‚Üí ${botMove.to.r},${botMove.to.c}`);
            }
          }
        }
      } catch (error) {
        console.error('Extended AI prediction failed, using fallback:', error);
        
        // Fallback to simple random prediction
        const botMoves = this.generateAllMoves(botColor);
        if (botMoves.length > 0) {
          const bestBotMove = botMoves[Math.floor(Math.random() * Math.min(3, botMoves.length))];
          this.createPredictionArrow(bestBotMove.from, bestBotMove.to, 90, 0);
        }
      }
      
      // Restore board
      this.board[playerMove.from.r][playerMove.from.c] = movingPiece;
      this.board[playerMove.to.r][playerMove.to.c] = originalPiece;
    },

    createPredictionArrow(from, to, confidence = 90, priority = 0) {
      const fromSquare = this.getSquareElement(from.r, from.c);
      const toSquare = this.getSquareElement(to.r, to.c);
      
      if (!fromSquare || !toSquare) return;
      
      const arrow = document.createElement('div');
      arrow.className = 'prediction-arrow';
      
      // Calculate arrow direction
      const deltaR = to.r - from.r;
      const deltaC = to.c - from.c;
      
      let arrowChar = '‚û°Ô∏è';
      if (deltaR > 0 && deltaC === 0) arrowChar = '‚¨áÔ∏è';
      else if (deltaR < 0 && deltaC === 0) arrowChar = '‚¨ÜÔ∏è';
      else if (deltaR === 0 && deltaC > 0) arrowChar = '‚û°Ô∏è';
      else if (deltaR === 0 && deltaC < 0) arrowChar = '‚¨ÖÔ∏è';
      else if (deltaR > 0 && deltaC > 0) arrowChar = '‚ÜòÔ∏è';
      else if (deltaR > 0 && deltaC < 0) arrowChar = '‚ÜôÔ∏è';
      else if (deltaR < 0 && deltaC > 0) arrowChar = '‚ÜóÔ∏è';
      else if (deltaR < 0 && deltaC < 0) arrowChar = '‚ÜñÔ∏è';
      
      // Create arrow with confidence percentage
      const arrowContainer = document.createElement('div');
      arrowContainer.className = `prediction-arrow-container priority-${priority}`;
      arrowContainer.style.cssText = `
        position: absolute;
        top: 2px;
        right: 2px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 4px;
        padding: 2px 4px;
        font-size: 10px;
        font-weight: bold;
        border: 1px solid #333;
        z-index: ${10 - priority};
        box-shadow: 0 1px 3px rgba(0,0,0,0.3);
      `;
      
      // Color coding based on confidence
      let confidenceColor = '#ff6b6b'; // Red for low confidence
      if (confidence >= 80) confidenceColor = '#51cf66'; // Green for high confidence
      else if (confidence >= 65) confidenceColor = '#ffd43b'; // Yellow for medium confidence
      else if (confidence >= 50) confidenceColor = '#ff9f43'; // Orange for low-medium confidence
      
      arrowContainer.style.backgroundColor = confidenceColor;
      arrowContainer.style.color = confidence >= 65 ? '#000' : '#fff';
      
      arrowContainer.innerHTML = `
        <div style="text-align: center;">
          <div style="font-size: 12px;">${arrowChar}</div>
          <div style="font-size: 9px;">${confidence}%</div>
        </div>
      `;
      
      // Position on the from square
      fromSquare.style.position = 'relative';
      fromSquare.appendChild(arrowContainer);
      
      // Also add visual indicator to target square
      const targetIndicator = document.createElement('div');
      targetIndicator.className = `prediction-target priority-${priority}`;
      targetIndicator.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: ${confidenceColor};
        opacity: 0.7;
        border: 2px solid #333;
        z-index: ${5 - priority};
        font-size: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: ${confidence >= 65 ? '#000' : '#fff'};
        font-weight: bold;
      `;
      targetIndicator.textContent = `${priority + 1}`;
      
      toSquare.style.position = 'relative';
      toSquare.appendChild(targetIndicator);
      
      console.log(`üèπ Prediction arrow: ${from.r},${from.c} ‚Üí ${to.r},${to.c} (${confidence}%)`);
    },

    async makeBotMove() {
      if (this.botMoveUsed) {
        alert('Bot move already used this game! Start a new game to use it again.');
        return;
      }
      
      if (this.gameOver) {
        alert('Game is over!');
        return;
      }
      
      console.log('ü§ñ Making bot move for current player with Extended AI...');
      
      try {
        const move = await extendedAI.makeAIMove(this, this.turn, 4); // Higher difficulty for bot move
        if (move) {
          this.botMoveUsed = true;
          
          // Update button to show used state
          const botMoveBtn = document.getElementById('bot-move-btn');
          botMoveBtn.disabled = true;
          botMoveBtn.textContent = 'USED';
          botMoveBtn.style.opacity = '0.5';
          
          // Make the move
          this.movePiece(move.from.r, move.from.c, move.to.r, move.to.c);
          
          console.log('üéØ Bot made move:', extendedAI.moveToString(move));
          
          // Show notification
          const notification = document.createElement('div');
          notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(45deg, #f59e0b, #ef4444);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            font-weight: bold;
            z-index: 1000;
            animation: slideIn 0.5s ease-out;
          `;
          notification.textContent = 'ü§ñ Bot move executed!';
          document.body.appendChild(notification);
          
          setTimeout(() => notification.remove(), 3000);
        } else {
          alert('No valid moves available!');
        }
      } catch (error) {
        console.error('Extended AI bot move failed:', error);
        alert('Bot move failed. Please try again.');
      }
    },

    clearHints() {
      // Clear regular hints
      document.querySelectorAll('.highlight').forEach(square => {
        square.classList.remove('highlight');
      });
      
      // Clear advanced hints
      document.querySelectorAll('.hint-primary, .hint-secondary').forEach(square => {
        square.classList.remove('hint-primary', 'hint-secondary');
      });
      
      // Clear prediction arrows and containers
      document.querySelectorAll('.prediction-arrow').forEach(arrow => {
        arrow.remove();
      });
      document.querySelectorAll('.prediction-arrow-container').forEach(container => {
        container.remove();
      });
      document.querySelectorAll('.prediction-target').forEach(target => {
        target.remove();
      });
    },

    getSquareElement(row, col) {
      return document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
    },

    resetGame() {
      this.board = Array(12).fill().map(() => Array(12).fill(null));
      this.turn = 'white';
      this.selectedSquare = null;
      this.possibleMoves = [];
      this.moveHistory = [];
      this.capturedPieces = { white: [], black: [] };
      this.check = false;
      this.gameOver = false;
      this.lastMove = null;
      this.promotingPawn = null;
      this.botMoveUsed = false; // Reset bot move availability
      
      // Reset bot move button
      const botMoveBtn = document.getElementById('bot-move-btn');
      if (botMoveBtn) {
        botMoveBtn.disabled = false;
        botMoveBtn.textContent = 'MAKE BOT MOVE';
        botMoveBtn.style.opacity = '1';
      }
      
      this.setupBoard();
      this.renderBoard();
      this.updateGameInfo();
      this.clearHints();
    }
  };

  game.init();
});
</script>
</body>
</html>
